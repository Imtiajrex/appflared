import {
	DiscoveredHandler,
	groupBy,
	isValidIdentifier,
	pascalCase,
	toImportPathFromGeneratedSrc,
	toImportPathFromGeneratedServer,
} from "./utils";

export function generateApiClient(params: {
	handlers: DiscoveredHandler[];
	outDirAbs: string;
}): string {
	const queries = params.handlers.filter((h) => h.kind === "query");
	const mutations = params.handlers.filter((h) => h.kind === "mutation");

	const queriesByFile = groupBy(queries, (h) => h.fileName);
	const mutationsByFile = groupBy(mutations, (h) => h.fileName);

	const sortedEntries = <T>(map: Map<string, T[]>): Array<[string, T[]]> =>
		Array.from(map.entries()).sort(([a], [b]) => a.localeCompare(b));

	const renderObjectKey = (key: string): string =>
		isValidIdentifier(key) ? key : JSON.stringify(key);

	const handlerTypePrefix = (h: DiscoveredHandler): string =>
		pascalCase(`${h.fileName}-${h.name}`);

	const typeBlocks: string[] = [];
	for (const h of params.handlers) {
		const importPath = toImportPathFromGeneratedSrc(
			params.outDirAbs,
			h.sourceFileAbs
		);
		const pascal = handlerTypePrefix(h);
		typeBlocks.push(
			`type ${pascal}Definition = typeof import(${JSON.stringify(importPath)})[${JSON.stringify(h.name)}];\n` +
				`type ${pascal}Args = HandlerArgs<${pascal}Definition>;\n` +
				`type ${pascal}Result = HandlerResult<${pascal}Definition>;`
		);
	}

	const queriesTypeLines = sortedEntries(queriesByFile)
		.map(([fileName, list]) => {
			const fileKey = renderObjectKey(fileName);
			const inner = list
				.slice()
				.sort((a, b) => a.name.localeCompare(b.name))
				.map((h) => {
					const pascal = handlerTypePrefix(h);
					return `\t\t${h.name}: HandlerInvoker<${pascal}Args, ${pascal}Result>;`;
				})
				.join("\n");
			return `\t${fileKey}: {\n${inner || "\t\t// (none)"}\n\t};`;
		})
		.join("\n");

	const mutationsTypeLines = sortedEntries(mutationsByFile)
		.map(([fileName, list]) => {
			const fileKey = renderObjectKey(fileName);
			const inner = list
				.slice()
				.sort((a, b) => a.name.localeCompare(b.name))
				.map((h) => {
					const pascal = handlerTypePrefix(h);
					return `\t\t${h.name}: HandlerInvoker<${pascal}Args, ${pascal}Result>;`;
				})
				.join("\n");
			return `\t${fileKey}: {\n${inner || "\t\t// (none)"}\n\t};`;
		})
		.join("\n");

	const queriesClientLines = sortedEntries(queriesByFile)
		.map(([fileName, list]) => {
			const fileKey = renderObjectKey(fileName);
			const inner = list
				.slice()
				.sort((a, b) => a.name.localeCompare(b.name))
				.map((h) => {
					const pascal = handlerTypePrefix(h);
					const route = `/queries/${fileName}/${h.name}`;
					return (
						`\t\t${h.name}: async (args: ${pascal}Args, init) => {\n` +
						`\t\t\tconst url = buildQueryUrl(baseUrl, ${JSON.stringify(route)}, args);\n` +
						`\t\t\tconst response = await request(url, {\n` +
						`\t\t\t\t...(init ?? {}),\n` +
						`\t\t\t\tmethod: "GET",\n` +
						`\t\t\t});\n` +
						`\t\t\treturn parseJson<${pascal}Result>(response);\n` +
						`\t\t},`
					);
				})
				.join("\n");
			return `\t${fileKey}: {\n${inner || "\t\t// (none)"}\n\t},`;
		})
		.join("\n");

	const mutationsClientLines = sortedEntries(mutationsByFile)
		.map(([fileName, list]) => {
			const fileKey = renderObjectKey(fileName);
			const inner = list
				.slice()
				.sort((a, b) => a.name.localeCompare(b.name))
				.map((h) => {
					const pascal = handlerTypePrefix(h);
					const route = `/mutations/${fileName}/${h.name}`;
					return (
						`\t\t${h.name}: async (args: ${pascal}Args, init) => {\n` +
						`\t\t\tconst url = buildUrl(baseUrl, ${JSON.stringify(route)});\n` +
						`\t\t\tconst response = await request(url, {\n` +
						`\t\t\t\t...(init ?? {}),\n` +
						`\t\t\t\tmethod: "POST",\n` +
						`\t\t\t\theaders: ensureJsonHeaders(init?.headers),\n` +
						`\t\t\t\tbody: JSON.stringify(args),\n` +
						`\t\t\t});\n` +
						`\t\t\treturn parseJson<${pascal}Result>(response);\n` +
						`\t\t},`
					);
				})
				.join("\n");
			return `\t${fileKey}: {\n${inner || "\t\t// (none)"}\n\t},`;
		})
		.join("\n");

	const queriesTypeDef =
		queriesByFile.size === 0 ? "{}" : `{\n${queriesTypeLines}\n}`;
	const mutationsTypeDef =
		mutationsByFile.size === 0 ? "{}" : `{\n${mutationsTypeLines}\n}`;

	const queriesInit =
		queriesByFile.size === 0 ? "{}" : `{\n${queriesClientLines}\n\t}`;
	const mutationsInit =
		mutationsByFile.size === 0 ? "{}" : `{\n${mutationsClientLines}\n\t}`;

	return `/* eslint-disable */
/**
 * This file is auto-generated by appflare/handler-build.ts.
 * Do not edit directly.
 */

import fetch from "better-fetch";

import type {
	AnyValidator,
	InferQueryArgs,
	MutationDefinition,
	QueryArgsShape,
	QueryDefinition,
} from "./schema-types";

type AnyArgsShape = Record<string, AnyValidator>;

type AnyHandlerDefinition = QueryDefinition<AnyArgsShape, unknown> | MutationDefinition<AnyArgsShape, unknown>;

type HandlerArgs<THandler extends AnyHandlerDefinition> =
	THandler extends { args: infer TArgs extends QueryArgsShape }
		? InferQueryArgs<TArgs>
		: never;

type HandlerResult<THandler extends AnyHandlerDefinition> = THandler extends {
	handler: (...args: any[]) => Promise<infer TResult>;
}
	? TResult
	: never;

type HandlerInvoker<TArgs, TResult> = (args: TArgs, init?: RequestInit) => Promise<TResult>;

type RequestExecutor = (
	input: RequestInfo | URL,
	init?: RequestInit
) => Promise<Response>;

const defaultFetcher: RequestExecutor = (input, init) => fetch(input, init);

${typeBlocks.join("\n\n")}

export type QueriesClient = ${queriesTypeDef};

export type MutationsClient = ${mutationsTypeDef};

export type AppflareApiClient = {
	queries: QueriesClient;
	mutations: MutationsClient;
};

export type AppflareApiOptions = {
	baseUrl?: string;
	fetcher?: RequestExecutor;
};

export function createAppflareApi(options: AppflareApiOptions = {}): AppflareApiClient {
	const baseUrl = normalizeBaseUrl(options.baseUrl);
	const request = options.fetcher ?? defaultFetcher;
	const queries: QueriesClient = ${queriesInit};
	const mutations: MutationsClient = ${mutationsInit};
	return { queries, mutations };
}

function normalizeBaseUrl(baseUrl?: string): string {
	if (!baseUrl) {
		return "";
	}
	return baseUrl.endsWith("/") ? baseUrl.slice(0, -1) : baseUrl;
}

function buildUrl(baseUrl: string, path: string): string {
	if (!baseUrl) {
		return path;
	}
	const normalizedPath = path.startsWith("/") ? path : "/" + path;
	return baseUrl + normalizedPath;
}

function buildQueryUrl(
	baseUrl: string,
	path: string,
	params: Record<string, unknown> | undefined
): string {
	const url = buildUrl(baseUrl, path);
	const query = serializeQueryParams(params);
	return query ? url + "?" + query : url;
}

function serializeQueryParams(
	params: Record<string, unknown> | undefined
): string {
	if (!params) {
		return "";
	}
	const searchParams = new URLSearchParams();
	for (const [key, value] of Object.entries(params)) {
		if (value === undefined || value === null) {
			continue;
		}
		if (Array.isArray(value)) {
			for (const entry of value) {
				searchParams.append(key, serializeQueryValue(entry));
			}
			continue;
		}
		searchParams.append(key, serializeQueryValue(value));
	}
	return searchParams.toString();
}

function serializeQueryValue(value: unknown): string {
	if (value instanceof Date) {
		return value.toISOString();
	}
	if (typeof value === "object") {
		return JSON.stringify(value);
	}
	return String(value);
}

function ensureJsonHeaders(headers?: HeadersInit): HeadersInit {
	if (!headers) {
		return { "content-type": "application/json" };
	}
	if (typeof Headers !== "undefined" && headers instanceof Headers) {
		const next = new Headers(headers);
		if (!next.has("content-type")) {
			next.set("content-type", "application/json");
		}
		return next;
	}
	if (Array.isArray(headers)) {
		const entries = headers.slice();
		const hasContentType = entries.some(
			([key]) => key.toLowerCase() === "content-type"
		);
		if (!hasContentType) {
			entries.push(["content-type", "application/json"]);
		}
		return entries;
	}
	if (typeof headers === "object") {
		const record = { ...(headers as Record<string, string>) };
		if (!hasHeader(record, "content-type")) {
			record["content-type"] = "application/json";
		}
		return record;
	}
	return { "content-type": "application/json" };
}

function hasHeader(record: Record<string, string>, name: string): boolean {
	const needle = name.toLowerCase();
	return Object.keys(record).some((key) => key.toLowerCase() === needle);
}

async function parseJson<TResult>(response: Response): Promise<TResult> {
	if (!response.ok) {
		throw new Error("Request failed with status " + response.status);
	}
	return (await response.json()) as TResult;
}
`;
}
