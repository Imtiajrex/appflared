import {
	DiscoveredHandler,
	groupBy,
	pascalCase,
	toImportPathFromGeneratedServer,
	AppflareConfig,
} from "../utils/utils";

export function generateWebsocketDurableObject(params: {
	handlers: DiscoveredHandler[];
	outDirAbs: string;
	schemaPathAbs: string;
	configPathAbs: string;
	config: AppflareConfig;
}): string {
	const queries = params.handlers.filter((h) => h.kind === "query");
	const schemaImportPath = toImportPathFromGeneratedServer(
		params.outDirAbs,
		params.schemaPathAbs
	);
	const configImportPath = toImportPathFromGeneratedServer(
		params.outDirAbs,
		params.configPathAbs
	);
	const schemaTypesImportPath = "../src/schema-types";
	const serverImportPath = "./server";
	const hasAuth = !!(
		params.config.auth && params.config.auth.enabled !== false
	);

	const localNameFor = (h: DiscoveredHandler): string =>
		`__appflare_${pascalCase(h.fileName)}_${h.name}`;

	const grouped = groupBy(queries, (h) => h.sourceFileAbs);
	const importLines: string[] = [];
	for (const [fileAbs, list] of Array.from(grouped.entries())) {
		const specifiers = list
			.slice()
			.sort((a, b) => a.name.localeCompare(b.name))
			.map((h) => `${h.name} as ${localNameFor(h)}`);
		const importPath = toImportPathFromGeneratedServer(
			params.outDirAbs,
			fileAbs
		);
		importLines.push(
			`import { ${specifiers.join(", ")} } from ${JSON.stringify(importPath)};`
		);
	}

	const authImportLine = hasAuth
		? 'import { initBetterAuth } from "appflare/server/auth";'
		: "";

	const authSetupBlock = hasAuth
		? [
				"const __appflareAuthConfig = (appflareConfig as any).auth;",
				"const __appflareAuth =",
				"\t__appflareAuthConfig &&",
				"\t__appflareAuthConfig.enabled !== false &&",
				"\t__appflareAuthConfig.options",
				"\t\t? initBetterAuth(__appflareAuthConfig.options as any)",
				"\t\t: undefined;",
			].join("\n")
		: "const __appflareAuth = undefined;";

	const queryHandlerEntries = queries
		.slice()
		.sort((a, b) => {
			if (a.fileName === b.fileName) return a.name.localeCompare(b.name);
			return a.fileName.localeCompare(b.fileName);
		})
		.map(
			(q) =>
				`	${JSON.stringify(`${q.fileName}/${q.name}`)}: { file: ${JSON.stringify(
					q.fileName
				)}, name: ${JSON.stringify(q.name)}, definition: ${localNameFor(q)} },`
		)
		.join("\n");

	return `/* eslint-disable */
/**
 * This file is auto-generated by appflare/handler-build.ts.
 * Do not edit directly.
 */

import { DurableObject } from "cloudflare:workers";
import {
	createAppflareDbContext,
	type AppflareDbContext,
	type AppflareServerContext,
} from ${JSON.stringify(serverImportPath)};
	import appflareConfig from ${JSON.stringify(configImportPath)};
import schema from ${JSON.stringify(schemaImportPath)};
import type {
	QueryWhere,
	QuerySort,
	TableNames,
		AppflareAuthContext,
		AppflareAuthSession,
		AppflareAuthUser,
	} from ${JSON.stringify(schemaTypesImportPath)};
import { MongoClient } from "mongodb";
	${authImportLine ? `${authImportLine}\n` : ""}${importLines.join("\n")}


	const emptyAuthContext: AppflareAuthContext = {
		session: null as AppflareAuthSession,
		user: null as AppflareAuthUser,
	};

	const resolveAuthContextFromToken = async (
		authToken?: string | null
	): Promise<AppflareAuthContext> => {
		${authSetupBlock}
		if (!__appflareAuth || !authToken) return emptyAuthContext;
		try {
			const request = new Request("http://appflare-internal/auth", {
				headers: { Authorization: \`Bearer \${authToken}\` },
			});
			const sessionResult = await __appflareAuth.api.getSession(request);
			return {
				session:
					(sessionResult as any)?.session ??
					(sessionResult as any) ??
					(null as AppflareAuthSession),
				user: (sessionResult as any)?.user ?? (null as AppflareAuthUser),
			};
		} catch (err) {
			console.error("Appflare websocket auth failed", err);
			return emptyAuthContext;
		}
	};

type SubscriptionQueryHandler = { file: string; name: string };

type Subscription = {
	table: TableNames;
	handler?: SubscriptionQueryHandler;
	args?: unknown;
	where?: QueryWhere<TableNames>;
	orderBy?: QuerySort<TableNames>;
	take?: number;
	skip?: number;
	select?: unknown;
	include?: unknown;
		authToken?: string | null;
		auth?: AppflareAuthContext;
};

type SubscriptionWithAuth = Subscription & { auth?: AppflareAuthContext };

type ParsedSubscription =
	| { ok: true; value: Subscription }
	| { ok: false; error: string };

type QueryArgsParser = { parse?: (value: unknown) => unknown };

type QueryHandlerDefinition = {
	args?: QueryArgsParser | unknown;
	handler: (
		ctx: import("./server").AppflareServerContext,
		args: unknown
	) => unknown | Promise<unknown>;
};

const queryHandlers = {
${queryHandlerEntries}
} satisfies Record<
	string,
	{ file: string; name: string; definition: QueryHandlerDefinition }
>;

type QueryHandlerKey = keyof typeof queryHandlers;

const pascalCase = (str: string): string =>
	str.replace(/(^\w|_\w)/g, (match) => match.replace("_", "").toUpperCase());
const defaultHandlerForTable = (
	table: TableNames
): SubscriptionQueryHandler | null => {
	const tableStr = table.toString();
	const possible = [tableStr];
	if (tableStr.endsWith("s")) {
		possible.push(tableStr.slice(0, -1));
	}
	for (const candidate of possible) {
		const key = candidate + "/get" + pascalCase(candidate);
		if (key in queryHandlers) {
			return { file: candidate, name: "get" + pascalCase(candidate) };
		}
	}
	return null;
};

const resolveDatabase = (env: any) => {
	const client = new MongoClient(env.MONGO_URI);
	const db = client.db(env.MONGO_DB);
	return db;
};

const formatHandlerError = (
	err: unknown
): { error: string; details?: unknown } => {
	const message =
		err instanceof Error
			? err.message
			: typeof err === "string"
				? err
				: "Unknown error";
	const includeDetails =
		err && typeof err === "object" && !(err instanceof Error) && !Array.isArray(err);
	return includeDetails ? { error: message, details: err } : { error: message };
};

type ErrorEnvelope = { __appflareError: true; payload: { error: string; details?: unknown } };

const makeErrorEnvelope = (err: unknown): ErrorEnvelope => ({
	__appflareError: true,
	payload: formatHandlerError(err),
});

const isErrorEnvelope = (value: unknown): value is ErrorEnvelope => {
	return !!value && typeof value === "object" && (value as any).__appflareError === true;
};

const handlerKey = (handler: SubscriptionQueryHandler): string =>
	handler.file + "/" + handler.name;

const resolveQueryHandler = (
	handler: SubscriptionQueryHandler | undefined
): QueryHandlerDefinition | null => {
	if (!handler) return null;
	const key = handlerKey(handler) as QueryHandlerKey;
	return queryHandlers[key]?.definition ?? null;
};

const isKnownQueryHandler = (
	handler: SubscriptionQueryHandler | undefined
): boolean => {
	if (!handler) return false;
	return handlerKey(handler) in queryHandlers;
};

export type MutationNotification = {
	table: TableNames;
	handler: { file: string; name: string };
	args: unknown;
	result?: unknown;
};

export class WebSocketHibernationServer extends DurableObject {
	private subscriptions: Map<WebSocket, SubscriptionWithAuth>;
	private db: AppflareDbContext | null;

	constructor(ctx: DurableObjectState, env: any) {
		super(ctx, env);
		this.env = env;
		this.subscriptions = new Map();
		this.db = null;

		for (const socket of this.ctx.getWebSockets()) {
			const restored = socket.deserializeAttachment() as
				| SubscriptionWithAuth
				| undefined;
			if (restored) {
				this.subscriptions.set(socket, restored);
			}
		}

		this.ctx.setWebSocketAutoResponse(
			new WebSocketRequestResponsePair("ping", "pong")
		);
	}

	private async withAuth(
		sub: Subscription
	): Promise<SubscriptionWithAuth> {
		if (!sub.authToken) return sub as SubscriptionWithAuth;
		if (sub.auth && sub.auth.session !== undefined) {
			return sub as SubscriptionWithAuth;
		}
		const auth = await resolveAuthContextFromToken(sub.authToken);
		return { ...sub, auth } as SubscriptionWithAuth;
	}

	async fetch(request: Request): Promise<Response> {
		const url = new URL(request.url);
		const pathname = url.pathname;

		if (request.headers.get("Upgrade") === "websocket" && pathname === "/ws") {
			const parsed = this.parseSubscription(url.searchParams);
			if (parsed.ok === false) {
				return new Response(parsed.error, { status: 400 });
			}
			return this.handleSubscribe(parsed.value);
		}

		if (pathname === "/notify" && request.method === "POST") {
			const payload = (await request
				.json()
				.catch(() => null)) as MutationNotification | null;
			if (!payload) {
				return new Response("Invalid mutation payload", { status: 400 });
			}
			await this.handleNotification(payload);
			return new Response("ok", { status: 200 });
		}

		return new Response("Not found", { status: 404 });
	}

	async webSocketMessage(
		ws: WebSocket,
		message: ArrayBuffer | string
	): Promise<void> {
		if (typeof message === "string" && message.toLowerCase() === "ping") {
			ws.send("pong");
			return;
		}
	}

	async webSocketClose(ws: WebSocket): Promise<void> {
		this.subscriptions.delete(ws);
	}

	private async handleSubscribe(sub: Subscription): Promise<Response> {
		try {
			const subWithAuth = await this.withAuth(sub);
			const { 0: client, 1: server } = Object.values(new WebSocketPair());
			server.serializeAttachment(subWithAuth);
			this.ctx.acceptWebSocket(server);
			this.subscriptions.set(server, subWithAuth);
			server.send(
				JSON.stringify({ type: "subscribed", subscription: subWithAuth })
			);

			try {
				const data = await this.fetchData(subWithAuth);
				server.send(
					JSON.stringify({
						type: "data",
						table: subWithAuth.table,
						where: subWithAuth.where,
						data,
					})
				);
			} catch (err) {
				const formatted = makeErrorEnvelope(err).payload;
				console.error("Failed to send initial payload", err);
				server.send(
					JSON.stringify({
						type: "error",
						...formatted,
					})
				);
			}

			return new Response(null, { status: 101, webSocket: client });
		} catch (err) {
			const formatted = formatHandlerError(err);
			console.error("Websocket subscription setup failed", err);
			return new Response(JSON.stringify(formatted), {
				status: 500,
				headers: { "content-type": "application/json" },
			});
		}
	}

	private parseSubscription(params: URLSearchParams): ParsedSubscription {
		const table = this.normalizeTableName(params.get("table"));
		if (!table) {
			return { ok: false, error: "Missing or invalid table param" };
		}
		const authToken = params.get("authToken");

		const parseJson = <T>(key: string): T | undefined => {
			const raw = params.get(key);
			if (!raw) return undefined;
			try {
				return JSON.parse(raw) as T;
			} catch (err) {
				console.error("Failed to parse " + key + " search param", err);
				return undefined;
			}
		};

		const handler = this.parseHandlerRef(params);
		let resolvedHandler = handler ?? defaultHandlerForTable(table) ?? undefined;

		if (resolvedHandler && !isKnownQueryHandler(resolvedHandler)) {
			return {
				ok: false,
				error:
					"Unknown query handler: " +
					resolvedHandler.file +
					"/" +
					resolvedHandler.name,
			};
		}

		const where = parseJson<QueryWhere<TableNames>>("where");
		const orderBy = parseJson<QuerySort<TableNames>>("orderBy");
		const select = parseJson<unknown>("select");
		const include = parseJson<unknown>("include");
		const args = parseJson<unknown>("args");
		const takeStr = params.get("take") ?? params.get("limit");
		const skipStr = params.get("skip") ?? params.get("offset");

		return {
			ok: true,
			value: {
				table,
				handler: resolvedHandler,
				args,
				where,
				orderBy,
				select,
				include,
				take: takeStr ? Number(takeStr) : undefined,
				skip: skipStr ? Number(skipStr) : undefined,
				authToken,
			},
		};
	}

	private parseHandlerRef(
		params: URLSearchParams
	): SubscriptionQueryHandler | undefined {
		const handlerCombined = params.get("handler");
		const handlerFile =
			params.get("handlerFile") ?? params.get("handler_file") ?? undefined;
		const handlerName =
			params.get("handlerName") ?? params.get("handler_name") ?? undefined;

		const fromCombined = this.tryParseHandlerCombined(handlerCombined);
		if (fromCombined) return fromCombined;
		if (handlerFile && handlerName) {
			return { file: handlerFile, name: handlerName };
		}
		return undefined;
	}

	private tryParseHandlerCombined(
		combined: string | null
	): SubscriptionQueryHandler | undefined {
		if (!combined) return undefined;

		try {
			const parsed = JSON.parse(combined) as SubscriptionQueryHandler;
			if (parsed && parsed.file && parsed.name) return parsed;
		} catch (err) {
			// ignore JSON parse failures and try other formats
		}

		if (combined.includes("/")) {
			const [file, name] = combined.split("/");
			if (file && name) return { file, name };
		}

		return undefined;
	}

	private async handleNotification(
		payload: MutationNotification
	): Promise<void> {
		const matches = Array.from(this.subscriptions.entries()).filter(([, sub]) =>
			this.shouldNotify(sub, payload)
		);
		if (matches.length === 0) return;

		const cache = new Map<string, unknown>();
		for (const [, sub] of matches) {
			const key = this.subscriptionKey(sub);
			if (!cache.has(key)) {
				try {
					cache.set(key, await this.fetchData(sub));
				} catch (err) {
					cache.set(key, makeErrorEnvelope(err));
					console.error("Failed to fetch subscription data for notification", err);
				}
			}
		}

		for (const [socket, sub] of matches) {
			const key = this.subscriptionKey(sub);
			const data = cache.get(key);
			try {
				if (isErrorEnvelope(data)) {
					socket.send(
						JSON.stringify({
							type: "error",
							...data.payload,
						})
					);
					continue;
				}
				socket.send(
					JSON.stringify({
						type: "data",
						table: sub.table,
						where: sub.where,
						data,
					})
				);
			} catch (err) {
				socket.close(1011, "send failed");
				this.subscriptions.delete(socket);
				console.error("Failed to notify websocket, closing", err);
			}
		}
	}

	private shouldNotify(
		sub: Subscription,
		payload: MutationNotification
	): boolean {
		if (payload.table !== sub.table) return false;

		const doc = this.extractDocument(payload);
		if (doc && this.matchesWhere(sub.where, doc)) return true;

		const mutationWhere = this.extractWhere(payload.args);
		if (!sub.where) return true;
		if (this.whereIntersects(sub.where, mutationWhere)) return true;
		return false;
	}

	private extractDocument(payload: MutationNotification):
		| Record<string, unknown>
		| null {
		const result = payload.result as unknown;
		if (result && typeof result === "object" && !Array.isArray(result)) {
			return result as Record<string, unknown>;
		}
		const args = payload.args as any;
		if (
			args &&
			typeof args === "object" &&
			args.data &&
			typeof args.data === "object"
		) {
			return args.data as Record<string, unknown>;
		}
		return null;
	}

	private extractWhere(args: unknown): Record<string, unknown> | undefined {
		if (!args || typeof args !== "object") return undefined;
		const obj = args as Record<string, unknown>;
		if (obj.where && typeof obj.where === "object") {
			return obj.where as Record<string, unknown>;
		}
		if (obj.id) {
			return { _id: obj.id } as Record<string, unknown>;
		}
		return undefined;
	}

	private whereIntersects(
		subWhere?: Record<string, unknown>,
		mutationWhere?: Record<string, unknown>
	): boolean {
		if (!subWhere) return true;
		if (!mutationWhere) return false;
		for (const [key, value] of Object.entries(subWhere)) {
			if (value === undefined) continue;
			if (key in mutationWhere && mutationWhere[key] !== value) {
				return false;
			}
		}
		return true;
	}

	private matchesWhere(
		where: Record<string, unknown> | undefined,
		doc: Record<string, unknown>
	): boolean {
		if (!where) return true;
		for (const [key, expected] of Object.entries(where)) {
			if (expected === undefined) continue;
			const value = doc[key];
			if (Array.isArray(expected)) {
				if (!Array.isArray(value)) return false;
				for (const entry of expected) {
					if (!value.includes(entry)) return false;
				}
				continue;
			}
			if (expected !== value) return false;
		}
		return true;
	}

	private async fetchData(sub: Subscription): Promise<unknown> {
		const subWithAuth = await this.withAuth(sub);
		const query = resolveQueryHandler(subWithAuth.handler);
		if (query) {
			const ctx = this.createHandlerContext(subWithAuth.auth);
			const parsedArgs = this.parseHandlerArgs(query, subWithAuth.where);
			return await query.handler(ctx, parsedArgs);
		}

		const db = this.getDb();
		const table = db[subWithAuth.table] as any;
		if (!table || typeof table.findMany !== "function") {
			throw new Error("Unknown table: " + subWithAuth.table);
		}
		const data = await table.findMany({
			where: subWithAuth.where as any,
			orderBy: subWithAuth.orderBy as any,
			skip: subWithAuth.skip,
			take: subWithAuth.take,
			select: subWithAuth.select as any,
			include: subWithAuth.include as any,
		});
		return data ?? [];
	}

	private parseHandlerArgs(
		query: QueryHandlerDefinition,
		args: unknown
	): unknown {
		if (query.args && typeof query.args === "object") {
			const parser = query.args as QueryArgsParser;
			if (parser.parse && typeof parser.parse === "function") {
				try {
					return parser.parse(args ?? {});
				} catch (err) {
					console.error("Failed to parse handler args", err);
				}
			}
		}
		return args ?? {};
	}

	private createHandlerContext(auth?: AppflareAuthContext): AppflareServerContext {
		return {
			db: this.getDb(),
			session: auth?.session ?? null,
			user: auth?.user ?? null,
		} as AppflareServerContext;
	}

	private getDb(): AppflareDbContext {
		if (!this.db) {
			this.db = createAppflareDbContext({
				db: resolveDatabase(this.env),
			});
		}
		return this.db;
	}

	private subscriptionKey(sub: Subscription): string {
		return JSON.stringify({
			table: sub.table,
			handler: sub.handler ?? null,
			args: sub.args ?? null,
			where: sub.where ?? null,
			orderBy: sub.orderBy ?? null,
			select: sub.select ?? null,
			include: sub.include ?? null,
			take: sub.take ?? null,
			skip: sub.skip ?? null,
		});
	}

	private normalizeTableName(table: string | null): TableNames | null {
		if (!table) return null;
		const schemaTables = schema as Record<string, unknown>;
		if (schemaTables[table]) return table as TableNames;
		const plural = table + "s";
		if (schemaTables[plural]) return plural as TableNames;
		return null;
	}
}
`;
}
