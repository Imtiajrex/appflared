const schemaTypesImportPath = "../src/schema-types";
const serverImportPath = "./server";

const indentBlock = (block: string, indent: string): string =>
	block
		.split("\n")
		.map((line) => (line ? indent + line : indent))
		.join("\n");

export type WebsocketDoTemplateParams = {
	schemaImportPath: string;
	configImportPath: string;
	handlerImports: string[];
	authImportLine: string;
	authSetupBlock: string;
	queryHandlerEntries: string;
};

export function renderWebsocketDurableObjectTemplate(
	params: WebsocketDoTemplateParams
): string {
	const authImportBlock = params.authImportLine
		? `${params.authImportLine}\n`
		: "";
	const handlerImportBlock =
		params.handlerImports.length > 0 ? params.handlerImports.join("\n") : "";
	const importsBlock =
		authImportBlock || handlerImportBlock
			? `${authImportBlock}${handlerImportBlock}\n\n`
			: "\n";
	const authSetupBlock = indentBlock(params.authSetupBlock, "\t");

	return `/* eslint-disable */
/**
 * This file is auto-generated by appflare/handler-build.ts.
 * Do not edit directly.
 */

import { DurableObject } from "cloudflare:workers";
import {
\tcreateAppflareDbContext,
\ttype AppflareDbContext,
\ttype AppflareServerContext,
} from ${JSON.stringify(serverImportPath)};
import appflareConfig from ${JSON.stringify(params.configImportPath)};
import schema from ${JSON.stringify(params.schemaImportPath)};
import type {
\tQueryWhere,
\tQuerySort,
\tTableNames,
\tAppflareAuthContext,
\tAppflareAuthSession,
\tAppflareAuthUser,
} from ${JSON.stringify(schemaTypesImportPath)};
import { MongoClient } from "mongodb";
${importsBlock}const emptyAuthContext: AppflareAuthContext = {
\tsession: null as AppflareAuthSession,
\tuser: null as AppflareAuthUser,
};

const resolveAuthContextFromToken = async (
	authToken?: string | null
): Promise<AppflareAuthContext> => {
${authSetupBlock}
	if (!__appflareAuth || !authToken) return emptyAuthContext;
	try {
		const request = new Request("http://appflare-internal/auth", {
			headers: { Authorization: \`Bearer \${authToken}\` },
		});
		const sessionResult = await __appflareAuth.api.getSession(request);
		return {
			session:
				(sessionResult as any)?.session ??
				(sessionResult as any) ??
				(null as AppflareAuthSession),
			user: (sessionResult as any)?.user ?? (null as AppflareAuthUser),
		};
	} catch (err) {
		console.error("Appflare websocket auth failed", err);
		return emptyAuthContext;
	}
};

type SubscriptionQueryHandler = { file: string; name: string };

type Subscription = {
\ttable: TableNames;
\thandler?: SubscriptionQueryHandler;
\targs?: unknown;
\twhere?: QueryWhere<TableNames>;
\torderBy?: QuerySort<TableNames>;
\ttake?: number;
\tskip?: number;
\tselect?: unknown;
\tinclude?: unknown;
\tauthToken?: string | null;
\tauth?: AppflareAuthContext;
};

type SubscriptionWithAuth = Subscription & { auth?: AppflareAuthContext };

type ParsedSubscription =
\t| { ok: true; value: Subscription }
\t| { ok: false; error: string };

type QueryArgsParser = { parse?: (value: unknown) => unknown };

type QueryHandlerDefinition = {
\targs?: QueryArgsParser | unknown;
\thandler: (
\t\tctx: import("./server").AppflareServerContext,
\t\targs: unknown
\t) => unknown | Promise<unknown>;
};

const queryHandlers = {
${params.queryHandlerEntries}
} satisfies Record<
\tstring,
\t{ file: string; name: string; definition: QueryHandlerDefinition }
>;

type QueryHandlerKey = keyof typeof queryHandlers;

const pascalCase = (str: string): string =>
\tstr.replace(/(^\w|_\w)/g, (match) => match.replace("_", "").toUpperCase());
const defaultHandlerForTable = (
\ttable: TableNames
): SubscriptionQueryHandler | null => {
\tconst tableStr = table.toString();
\tconst possible = [tableStr];
\tif (tableStr.endsWith("s")) {
\t\tpossible.push(tableStr.slice(0, -1));
\t}
\tfor (const candidate of possible) {
\t\tconst key = candidate + "/get" + pascalCase(candidate);
\t\tif (key in queryHandlers) {
\t\t\treturn { file: candidate, name: "get" + pascalCase(candidate) };
\t\t}
\t}
\treturn null;
};

const resolveDatabase = (env: any) => {
\tconst client = new MongoClient(env.MONGO_URI);
\tconst db = client.db(env.MONGO_DB);
\treturn db;
};

const formatHandlerError = (
\terr: unknown
): { error: string; details?: unknown } => {
\tconst message =
\t\terr instanceof Error
\t\t\t? err.message
\t\t\t: typeof err === "string"
\t\t\t\t? err
\t\t\t\t: "Unknown error";
\tconst includeDetails =
\t\terr && typeof err === "object" && !(err instanceof Error) && !Array.isArray(err);
\treturn includeDetails ? { error: message, details: err } : { error: message };
};

type ErrorEnvelope = { __appflareError: true; payload: { error: string; details?: unknown } };

const makeErrorEnvelope = (err: unknown): ErrorEnvelope => ({
\t__appflareError: true,
\tpayload: formatHandlerError(err),
});

const isErrorEnvelope = (value: unknown): value is ErrorEnvelope => {
\treturn !!value && typeof value === "object" && (value as any).__appflareError === true;
};

const handlerKey = (handler: SubscriptionQueryHandler): string =>
\thandler.file + "/" + handler.name;

const resolveQueryHandler = (
\thandler: SubscriptionQueryHandler | undefined
): QueryHandlerDefinition | null => {
\tif (!handler) return null;
\tconst key = handlerKey(handler) as QueryHandlerKey;
\treturn queryHandlers[key]?.definition ?? null;
};

const isKnownQueryHandler = (
\thandler: SubscriptionQueryHandler | undefined
): boolean => {
\tif (!handler) return false;
\treturn handlerKey(handler) in queryHandlers;
};

export type MutationNotification = {
\ttable: TableNames;
\thandler: { file: string; name: string };
\targs: unknown;
\tresult?: unknown;
};

export class WebSocketHibernationServer extends DurableObject {
\tprivate subscriptions: Map<WebSocket, SubscriptionWithAuth>;
\tprivate db: AppflareDbContext | null;

\tconstructor(ctx: DurableObjectState, env: any) {
\t\tsuper(ctx, env);
\t\tthis.env = env;
\t\tthis.subscriptions = new Map();
\t\tthis.db = null;

\t\tfor (const socket of this.ctx.getWebSockets()) {
\t\t\tconst restored = socket.deserializeAttachment() as
\t\t\t\t| SubscriptionWithAuth
\t\t\t\t| undefined;
\t\t\tif (restored) {
\t\t\t\tthis.subscriptions.set(socket, restored);
\t\t\t}
\t\t}

\t\tthis.ctx.setWebSocketAutoResponse(
\t\t\tnew WebSocketRequestResponsePair("ping", "pong")
\t\t);
\t}

\tprivate async withAuth(
\t\tsub: Subscription
\t): Promise<SubscriptionWithAuth> {
\t\tif (!sub.authToken) return sub as SubscriptionWithAuth;
\t\tif (sub.auth && sub.auth.session !== undefined) {
\t\t\treturn sub as SubscriptionWithAuth;
\t\t}
\t\tconst auth = await resolveAuthContextFromToken(sub.authToken);
\t\treturn { ...sub, auth } as SubscriptionWithAuth;
\t}

\tasync fetch(request: Request): Promise<Response> {
\t\tconst url = new URL(request.url);
\t\tconst pathname = url.pathname;

\t\tif (request.headers.get("Upgrade") === "websocket" && pathname === "/ws") {
\t\t\tconst parsed = this.parseSubscription(url.searchParams);
\t\t\tif (parsed.ok === false) {
\t\t\t\treturn new Response(parsed.error, { status: 400 });
\t\t\t}
\t\t\treturn this.handleSubscribe(parsed.value);
\t\t}

\t\tif (pathname === "/notify" && request.method === "POST") {
\t\t\tconst payload = (await request
\t\t\t\t.json()
\t\t\t\t.catch(() => null)) as MutationNotification | null;
\t\t\tif (!payload) {
\t\t\t\treturn new Response("Invalid mutation payload", { status: 400 });
\t\t\t}
\t\t\tawait this.handleNotification(payload);
\t\t\treturn new Response("ok", { status: 200 });
\t\t}

\t\treturn new Response("Not found", { status: 404 });
\t}

\tasync webSocketMessage(
\t\tws: WebSocket,
\t\tmessage: ArrayBuffer | string
\t): Promise<void> {
\t\tif (typeof message === "string" && message.toLowerCase() === "ping") {
\t\t\tws.send("pong");
\t\t\treturn;
\t\t}
\t}

\tasync webSocketClose(ws: WebSocket): Promise<void> {
\t\tthis.subscriptions.delete(ws);
\t}

\tprivate async handleSubscribe(sub: Subscription): Promise<Response> {
\t\ttry {
\t\t\tconst subWithAuth = await this.withAuth(sub);
\t\t\tconst { 0: client, 1: server } = Object.values(new WebSocketPair());
\t\t\tserver.serializeAttachment(subWithAuth);
\t\t\tthis.ctx.acceptWebSocket(server);
\t\t\tthis.subscriptions.set(server, subWithAuth);
\t\t\tserver.send(
\t\t\t\tJSON.stringify({ type: "subscribed", subscription: subWithAuth })
\t\t\t);

\t\t\ttry {
\t\t\t\tconst data = await this.fetchData(subWithAuth);
\t\t\t\tserver.send(
\t\t\t\t\tJSON.stringify({
\t\t\t\t\t\ttype: "data",
\t\t\t\t\t\ttable: subWithAuth.table,
\t\t\t\t\t\twhere: subWithAuth.where,
\t\t\t\t\t\tdata,
\t\t\t\t\t})
\t\t\t\t);
\t\t\t} catch (err) {
\t\t\t\tconst formatted = makeErrorEnvelope(err).payload;
\t\t\t\tconsole.error("Failed to send initial payload", err);
\t\t\t\tserver.send(
\t\t\t\t\tJSON.stringify({
\t\t\t\t\t\ttype: "error",
\t\t\t\t\t\t...formatted,
\t\t\t\t\t})
\t\t\t\t);
\t\t\t}

\t\t\treturn new Response(null, { status: 101, webSocket: client });
\t\t} catch (err) {
\t\t\tconst formatted = formatHandlerError(err);
\t\t\tconsole.error("Websocket subscription setup failed", err);
\t\t\treturn new Response(JSON.stringify(formatted), {
\t\t\t\tstatus: 500,
\t\t\t\theaders: { "content-type": "application/json" },
\t\t\t});
\t\t}
\t}

\tprivate parseSubscription(params: URLSearchParams): ParsedSubscription {
\t\tconst table = this.normalizeTableName(params.get("table"));
\t\tif (!table) {
\t\t\treturn { ok: false, error: "Missing or invalid table param" };
\t\t}
\t\tconst authToken = params.get("authToken");

\t\tconst parseJson = <T>(key: string): T | undefined => {
\t\t\tconst raw = params.get(key);
\t\t\tif (!raw) return undefined;
\t\t\ttry {
\t\t\t\treturn JSON.parse(raw) as T;
\t\t\t} catch (err) {
\t\t\t\tconsole.error("Failed to parse " + key + " search param", err);
\t\t\t\treturn undefined;
\t\t\t}
\t\t};

\t\tconst handler = this.parseHandlerRef(params);
\t\tlet resolvedHandler = handler ?? defaultHandlerForTable(table) ?? undefined;

\t\tif (resolvedHandler && !isKnownQueryHandler(resolvedHandler)) {
\t\t\treturn {
\t\t\t\tok: false,
\t\t\t\terror:
\t\t\t\t\t"Unknown query handler: " +
\t\t\t\t\tresolvedHandler.file +
\t\t\t\t\t"/" +
\t\t\t\t\tresolvedHandler.name,
\t\t\t};
\t\t}

\t\tconst where = parseJson<QueryWhere<TableNames>>("where");
\t\tconst orderBy = parseJson<QuerySort<TableNames>>("orderBy");
\t\tconst select = parseJson<unknown>("select");
\t\tconst include = parseJson<unknown>("include");
\t\tconst args = parseJson<unknown>("args");
\t\tconst takeStr = params.get("take") ?? params.get("limit");
\t\tconst skipStr = params.get("skip") ?? params.get("offset");

\t\treturn {
\t\t\tok: true,
\t\t\tvalue: {
\t\t\t\ttable,
\t\t\t\thandler: resolvedHandler,
\t\t\t\targs,
\t\t\t\twhere,
\t\t\t\torderBy,
\t\t\t\tselect,
\t\t\t\tinclude,
\t\t\t\ttake: takeStr ? Number(takeStr) : undefined,
\t\t\t\tskip: skipStr ? Number(skipStr) : undefined,
\t\t\t\tauthToken,
\t\t\t},
\t\t};
\t}

\tprivate parseHandlerRef(
\t\tparams: URLSearchParams
\t): SubscriptionQueryHandler | undefined {
\t\tconst handlerCombined = params.get("handler");
\t\tconst handlerFile =
\t\t\tparams.get("handlerFile") ?? params.get("handler_file") ?? undefined;
\t\tconst handlerName =
\t\t\tparams.get("handlerName") ?? params.get("handler_name") ?? undefined;

\t\tconst fromCombined = this.tryParseHandlerCombined(handlerCombined);
\t\tif (fromCombined) return fromCombined;
\t\tif (handlerFile && handlerName) {
\t\t\treturn { file: handlerFile, name: handlerName };
\t\t}
\t\treturn undefined;
\t}

\tprivate tryParseHandlerCombined(
\t\tcombined: string | null
\t): SubscriptionQueryHandler | undefined {
\t\tif (!combined) return undefined;

\t\ttry {
\t\t\tconst parsed = JSON.parse(combined) as SubscriptionQueryHandler;
\t\t\tif (parsed && parsed.file && parsed.name) return parsed;
\t\t} catch (err) {
\t\t\t// ignore JSON parse failures and try other formats
\t\t}

\t\tif (combined.includes("/")) {
\t\t\tconst [file, name] = combined.split("/");
\t\t\tif (file && name) return { file, name };
\t\t}

\t\treturn undefined;
\t}

\tprivate async handleNotification(
\t\tpayload: MutationNotification
\t): Promise<void> {
\t\tconst matches = Array.from(this.subscriptions.entries()).filter(([, sub]) =>
\t\t\tthis.shouldNotify(sub, payload)
\t\t);
\t\tif (matches.length === 0) return;

\t\tconst cache = new Map<string, unknown>();
\t\tfor (const [, sub] of matches) {
\t\t\tconst key = this.subscriptionKey(sub);
\t\t\tif (!cache.has(key)) {
\t\t\t\ttry {
\t\t\t\t\tcache.set(key, await this.fetchData(sub));
\t\t\t\t} catch (err) {
\t\t\t\t\tcache.set(key, makeErrorEnvelope(err));
\t\t\t\t\tconsole.error("Failed to fetch subscription data for notification", err);
\t\t\t\t}
\t\t\t}
\t\t}

\t\tfor (const [socket, sub] of matches) {
\t\t\tconst key = this.subscriptionKey(sub);
\t\t\tconst data = cache.get(key);
\t\t\ttry {
\t\t\t\tif (isErrorEnvelope(data)) {
\t\t\t\t\tsocket.send(
\t\t\t\t\t\tJSON.stringify({
\t\t\t\t\t\t\ttype: "error",
\t\t\t\t\t\t\t...data.payload,
\t\t\t\t\t\t})
							);
\t\t\t\t\tcontinue;
\t\t\t\t}
\t\t\t\tsocket.send(
\t\t\t\t\tJSON.stringify({
\t\t\t\t\t\ttype: "data",
\t\t\t\t\t\ttable: sub.table,
\t\t\t\t\t\twhere: sub.where,
\t\t\t\t\t\tdata,
\t\t\t\t\t})
\t\t\t\t);
\t\t\t} catch (err) {
\t\t\t\tsocket.close(1011, "send failed");
\t\t\t\tthis.subscriptions.delete(socket);
\t\t\t\tconsole.error("Failed to notify websocket, closing", err);
\t\t\t}
\t\t}
\t}

\tprivate shouldNotify(
\t\tsub: Subscription,
\t\tpayload: MutationNotification
\t): boolean {
\t\tif (payload.table !== sub.table) return false;

\t\tconst doc = this.extractDocument(payload);
\t\tif (doc && this.matchesWhere(sub.where, doc)) return true;

\t\tconst mutationWhere = this.extractWhere(payload.args);
\t\tif (!sub.where) return true;
\t\tif (this.whereIntersects(sub.where, mutationWhere)) return true;
\t\treturn false;
\t}

\tprivate extractDocument(payload: MutationNotification):
\t\t| Record<string, unknown>
\t\t| null {
\t\tconst result = payload.result as unknown;
\t\tif (result && typeof result === "object" && !Array.isArray(result)) {
\t\t\treturn result as Record<string, unknown>;
\t\t}
\t\tconst args = payload.args as any;
\t\tif (
\t\t\targs &&
\t\t\ttypeof args === "object" &&
\t\t\targs.data &&
\t\t\ttypeof args.data === "object"
\t\t) {
\t\t\treturn args.data as Record<string, unknown>;
\t\t}
\t\treturn null;
\t}

\tprivate extractWhere(args: unknown): Record<string, unknown> | undefined {
\t\tif (!args || typeof args !== "object") return undefined;
\t\tconst obj = args as Record<string, unknown>;
\t\tif (obj.where && typeof obj.where === "object") {
\t\t\treturn obj.where as Record<string, unknown>;
\t\t}
\t\tif (obj.id) {
\t\t\treturn { _id: obj.id } as Record<string, unknown>;
\t\t}
\t\treturn undefined;
\t}

\tprivate whereIntersects(
\t\tsubWhere?: Record<string, unknown>,
\t\tmutationWhere?: Record<string, unknown>
\t): boolean {
\t\tif (!subWhere) return true;
\t\tif (!mutationWhere) return false;
\t\tfor (const [key, value] of Object.entries(subWhere)) {
\t\t\tif (value === undefined) continue;
\t\t\tif (key in mutationWhere && mutationWhere[key] !== value) {
\t\t\t\treturn false;
\t\t\t}
\t\t}
\t\treturn true;
\t}

\tprivate matchesWhere(
\t\twhere: Record<string, unknown> | undefined,
\t\tdoc: Record<string, unknown>
\t): boolean {
\t\tif (!where) return true;
\t\tfor (const [key, expected] of Object.entries(where)) {
\t\t\tif (expected === undefined) continue;
\t\t\tconst value = doc[key];
\t\t\tif (Array.isArray(expected)) {
\t\t\t\tif (!Array.isArray(value)) return false;
\t\t\t\tfor (const entry of expected) {
\t\t\t\t\tif (!value.includes(entry)) return false;
\t\t\t\t}
\t\t\t\tcontinue;
\t\t\t}
\t\t\tif (expected !== value) return false;
\t\t}
\t\treturn true;
\t}

\tprivate async fetchData(sub: Subscription): Promise<unknown> {
\t\tconst subWithAuth = await this.withAuth(sub);
\t\tconst query = resolveQueryHandler(subWithAuth.handler);
\t\tif (query) {
\t\t\tconst ctx = this.createHandlerContext(subWithAuth.auth);
\t\t\tconst parsedArgs = this.parseHandlerArgs(query, subWithAuth.where);
\t\t\treturn await query.handler(ctx, parsedArgs);
\t\t}

\t\tconst db = this.getDb();
\t\tconst table = db[subWithAuth.table] as any;
\t\tif (!table || typeof table.findMany !== "function") {
\t\t\tthrow new Error("Unknown table: " + subWithAuth.table);
\t\t}
\t\tconst data = await table.findMany({
\t\t\twhere: subWithAuth.where as any,
\t\t\torderBy: subWithAuth.orderBy as any,
\t\t\tskip: subWithAuth.skip,
\t\t\ttake: subWithAuth.take,
\t\t\tselect: subWithAuth.select as any,
\t\t\tinclude: subWithAuth.include as any,
\t\t});
\t\treturn data ?? [];
\t}

\tprivate parseHandlerArgs(
\t\tquery: QueryHandlerDefinition,
\t\targs: unknown
\t): unknown {
\t\tif (query.args && typeof query.args === "object") {
\t\t\tconst parser = query.args as QueryArgsParser;
\t\t\tif (parser.parse && typeof parser.parse === "function") {
\t\t\t\ttry {
\t\t\t\t\treturn parser.parse(args ?? {});
\t\t\t\t} catch (err) {
\t\t\t\t\tconsole.error("Failed to parse handler args", err);
\t\t\t\t}
\t\t\t}
\t\t}
\t\treturn args ?? {};
\t}

\tprivate createHandlerContext(auth?: AppflareAuthContext): AppflareServerContext {
\t\treturn {
\t\t\tdb: this.getDb(),
\t\t\tsession: auth?.session ?? null,
\t\t\tuser: auth?.user ?? null,
\t\t} as AppflareServerContext;
\t}

\tprivate getDb(): AppflareDbContext {
\t\tif (!this.db) {
\t\t\tthis.db = createAppflareDbContext({
\t\t\t\tdb: resolveDatabase(this.env),
\t\t\t});
\t\t}
\t\treturn this.db;
\t}

\tprivate subscriptionKey(sub: Subscription): string {
\t\treturn JSON.stringify({
\t\t\ttable: sub.table,
\t\t\thandler: sub.handler ?? null,
\t\t\targs: sub.args ?? null,
\t\t\twhere: sub.where ?? null,
\t\t\torderBy: sub.orderBy ?? null,
\t\t\tselect: sub.select ?? null,
\t\t\tinclude: sub.include ?? null,
\t\t\ttake: sub.take ?? null,
\t\t\tskip: sub.skip ?? null,
\t\t});
\t}

\tprivate normalizeTableName(table: string | null): TableNames | null {
\t\tif (!table) return null;
\t\tconst schemaTables = schema as Record<string, unknown>;
\t\tif (schemaTables[table]) return table as TableNames;
\t\tconst plural = table + "s";
\t\tif (schemaTables[plural]) return plural as TableNames;
\t\treturn null;
\t}
}
`;
}
