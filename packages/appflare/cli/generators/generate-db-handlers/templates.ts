type HandlerTemplateParams = {
	tableName: string;
	pascalName: string;
};

type ExportLineParams = {
	tableName: string;
	pascalName: string;
};

export const buildHandlerFileContent = (
	params: HandlerTemplateParams
): string => {
	const findFn = `find${params.pascalName}`;
	const findOneFn = `findOne${params.pascalName}`;
	const sumFn = `sum${params.pascalName}`;
	const avgFn = `avg${params.pascalName}`;
	const insertFn = `insert${params.pascalName}`;
	const updateFn = `update${params.pascalName}`;
	const deleteFn = `delete${params.pascalName}`;

	return `/* eslint-disable */
/**
 * This file is auto-generated by appflare/db-build.ts.
 * Do not edit directly.
 */
import { z } from "zod";
import {
	internalMutation,
	internalQuery,
	type AppflareInclude,
	type EditableDoc,
	type Doc,
	type Id,
	type QuerySort,
	type QueryWhere,
} from "../schema-types";

export const ${findFn} = internalQuery({
	args: {
		where: z.custom<QueryWhere<${JSON.stringify(params.tableName)}>>()
			.optional(),
		sort: z.custom<QuerySort<${JSON.stringify(params.tableName)}>>()
			.optional(),
		limit: z.number().int().nonnegative().optional(),
		offset: z.number().int().nonnegative().optional(),
		include: z.custom<AppflareInclude<Doc<${JSON.stringify(params.tableName)}>>>()
			.optional(),
	},
	handler: async (ctx, args) => {
		return ctx.db[${JSON.stringify(params.tableName)} as any].findMany({
			where: args.where as any,
			orderBy: args.sort as any,
			skip: args.offset,
			take: args.limit,
				include: args.include as any,
		});
	},
});

export const ${findOneFn} = internalQuery({
	args: {
		where: z.custom<QueryWhere<${JSON.stringify(params.tableName)}>>()
			.optional(),
		sort: z.custom<QuerySort<${JSON.stringify(params.tableName)}>>()
			.optional(),
		offset: z.number().int().nonnegative().optional(),
		include: z.custom<AppflareInclude<Doc<${JSON.stringify(params.tableName)}>>>()
			.optional(),
	},
	handler: async (ctx, args) => {
		return ctx.db[${JSON.stringify(params.tableName)} as any].findFirst({
			where: args.where as any,
			orderBy: args.sort as any,
			skip: args.offset,
			take: 1,
				include: args.include as any,
		});
	},
});

export const ${sumFn} = internalQuery({
	args: {
		fields: z.array(z.string()).min(1),
		where: z.custom<QueryWhere<${JSON.stringify(params.tableName)}>>()
			.optional(),
		groupBy: z.union([z.string(), z.array(z.string())]).optional(),
		populate: z.custom<AppflareInclude<Doc<${JSON.stringify(params.tableName)}>>>()
			.optional(),
	},
	handler: async (ctx, args) => {
		return ctx.db[${JSON.stringify(params.tableName)} as any].aggregate({
			where: args.where as any,
			groupBy: args.groupBy as any,
			sum: args.fields as any,
			populate: args.populate as any,
		});
	},
});

export const ${avgFn} = internalQuery({
	args: {
		fields: z.array(z.string()).min(1),
		where: z.custom<QueryWhere<${JSON.stringify(params.tableName)}>>()
			.optional(),
		groupBy: z.union([z.string(), z.array(z.string())]).optional(),
		populate: z.custom<AppflareInclude<Doc<${JSON.stringify(params.tableName)}>>>()
			.optional(),
	},
	handler: async (ctx, args) => {
		return ctx.db[${JSON.stringify(params.tableName)} as any].aggregate({
			where: args.where as any,
			groupBy: args.groupBy as any,
			avg: args.fields as any,
			populate: args.populate as any,
		});
	},
});

export const ${insertFn} = internalMutation({
	args: {
		value: z.custom<EditableDoc<${JSON.stringify(params.tableName)}>>(),
	},
	handler: async (ctx, args) => {
		return ctx.db[${JSON.stringify(params.tableName)} as any].create({
			data: args.value as any,
		});
	},
});

export const ${updateFn} = internalMutation({
	args: {
		id: z.custom<Id<${JSON.stringify(params.tableName)}>>().optional(),
		where: z.custom<QueryWhere<${JSON.stringify(params.tableName)}>>()
			.optional(),
		partial: z.custom<Partial<EditableDoc<${JSON.stringify(params.tableName)}>>>(),
	},
	handler: async (ctx, args) => {
		const filter = (args.where ?? args.id) as any;
		if (!filter) {
			throw new Error("update requires either args.where or args.id");
		}
		await ctx.db[${JSON.stringify(params.tableName)} as any].update({
			where: filter,
			data: args.partial as any,
		});
	},
});

export const ${deleteFn} = internalMutation({
	args: {
		id: z.custom<Id<${JSON.stringify(params.tableName)}>>().optional(),
		where: z.custom<QueryWhere<${JSON.stringify(params.tableName)}>>()
			.optional(),
	},
	handler: async (ctx, args) => {
		const filter = (args.where ?? args.id) as any;
		if (!filter) {
			throw new Error("delete requires either args.where or args.id");
		}
		await ctx.db[${JSON.stringify(params.tableName)} as any].delete({
			where: filter,
		});
	},
});
`;
};

export const buildExportLine = (params: ExportLineParams): string => {
	const findFn = `find${params.pascalName}`;
	const findOneFn = `findOne${params.pascalName}`;
	const sumFn = `sum${params.pascalName}`;
	const avgFn = `avg${params.pascalName}`;
	const insertFn = `insert${params.pascalName}`;
	const updateFn = `update${params.pascalName}`;
	const deleteFn = `delete${params.pascalName}`;

	return `export { ${findFn}, ${findOneFn}, ${sumFn}, ${avgFn}, ${insertFn}, ${updateFn}, ${deleteFn} } from "./${params.tableName}";`;
};

export const buildIndexFileContent = (
	exportLines: string[]
): string => `/* eslint-disable */
/**
 * This file is auto-generated by appflare/db-build.ts.
 * Do not edit directly.
 */
${exportLines.join("\n")}
`;
