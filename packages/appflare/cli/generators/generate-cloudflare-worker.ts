import path from "node:path";
import type { AppflareConfig } from "../utils/utils";

const DEFAULT_ALLOWED_ORIGINS = ["http://localhost:3000"];

const resolveAllowedOrigins = (origins?: string[]): string[] =>
	origins && origins.length > 0 ? origins : DEFAULT_ALLOWED_ORIGINS;

const sanitizeWorkerName = (configDirAbs: string): string => {
	const base = path.basename(configDirAbs);
	const slug = base.replace(/[^A-Za-z0-9_-]/g, "-").toLowerCase();
	return slug || "appflare-worker";
};

const toBucketName = (binding: string): string =>
	binding.toLowerCase().replace(/_/g, "-") || "appflare-storage";

export function generateCloudflareWorkerIndex(params: {
	allowedOrigins?: string[];
}): string {
	const allowedOrigins = resolveAllowedOrigins(params.allowedOrigins);
	const allowedOriginsCsv = allowedOrigins.join(",");

	return `/* eslint-disable */
/**
 * This file is auto-generated by the Appflare CLI.
 * Do not edit directly.
 */

import { createAppflareHonoServer } from "./server";
import { WebSocketHibernationServer } from "./websocket-hibernation-server";
import { getDatabase } from "cloudflare-do-mongo";
import { MONGO_DURABLE_OBJECT } from "cloudflare-do-mongo/do";
import type { Hono } from "hono";
import { cors } from "hono/cors";
import { Db } from "mongodb";

type DurableObjectNamespaceLike = {
	idFromName(name: string): any;
	get(id: any): { fetch(input: any, init?: RequestInit): Promise<Response> };
};

type Env = {
	MONGO_DB: unknown;
	MONGO_URI?: string;
	WEBSOCKET_HIBERNATION_SERVER: DurableObjectNamespaceLike;
	MONGO_DURABLE_OBJECT: DurableObjectNamespaceLike;
	APPFLARE_STORAGE?: unknown;
	ALLOWED_ORIGINS?: string;
};

type WorkerEnv = { Bindings: Env };

const parseAllowedOrigins = (value?: string | null): string[] =>
	(value ?? ${JSON.stringify(allowedOriginsCsv)})
		.split(",")
		.map((origin) => origin.trim())
		.filter(Boolean);

const resolveCorsOrigin = (
	origin: string | null,
	allowed: string[]
): string | undefined => {
	if (!origin) return undefined;
	if (allowed.includes("*")) return origin;
	return allowed.includes(origin) ? origin : undefined;
};

export default {
	async fetch(request, env, ctx): Promise<Response> {
		const allowedOrigins = parseAllowedOrigins(env.ALLOWED_ORIGINS);
		const resolveOrigin = (origin: string | null) =>
			resolveCorsOrigin(origin, allowedOrigins);

		const app = createAppflareHonoServer({
			db: getDatabase(env.MONGO_DB) as unknown as Db,
			corsOrigin: allowedOrigins,
			realtime: {
				durableObject: env.WEBSOCKET_HIBERNATION_SERVER,
				durableObjectName: "primary",
				notify: async (payload) => {
					const id = env.WEBSOCKET_HIBERNATION_SERVER.idFromName("primary");
					const stub = env.WEBSOCKET_HIBERNATION_SERVER.get(id);
					await stub.fetch("http://appflare-realtime/notify", {
						method: "POST",
						headers: { "content-type": "application/json" },
						body: JSON.stringify(payload),
					});
				},
			},
		}) as unknown as Hono<WorkerEnv>;

		app.use(
			"*",
			cors({
				origin: resolveOrigin,
				credentials: true,
				allowMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
				allowHeaders: ["Content-Type", "Authorization", "Cookie"],
				exposeHeaders: ["set-cookie"],
			})
		);

		const origin = request.headers.get("Origin");
		const allowedOrigin = resolveOrigin(origin);
		if (request.method === "OPTIONS") {
			return new Response(null, {
				status: 204,
				headers: {
					"Access-Control-Allow-Origin": allowedOrigin ?? "",
					"Access-Control-Allow-Credentials": "true",
					"Access-Control-Allow-Methods": "GET,POST,PUT,DELETE,OPTIONS",
					"Access-Control-Allow-Headers":
						request.headers.get("Access-Control-Request-Headers") ??
						"Content-Type, Authorization, Cookie",
					Vary: "Origin",
				},
			});
		}

		const upgradeHeader = request.headers.get("Upgrade");
		if (upgradeHeader === "websocket") {
			const url = new URL(request.url);
			if (url.pathname === "/ws") {
				const id = env.WEBSOCKET_HIBERNATION_SERVER.idFromName("primary");
				const stub = env.WEBSOCKET_HIBERNATION_SERVER.get(id);
				return stub.fetch(request);
			}
		}

		const response = await app.fetch(request, env, ctx);
		if (allowedOrigin) {
			response.headers.set("Access-Control-Allow-Origin", allowedOrigin);
			response.headers.set("Access-Control-Allow-Credentials", "true");
			response.headers.append("Vary", "Origin");
		}
		return response;
	},
} satisfies ExportedHandler<Env>;

export { MONGO_DURABLE_OBJECT, WebSocketHibernationServer };
`;
}

export function generateWranglerJson(params: {
	config: AppflareConfig;
	configDirAbs: string;
	allowedOrigins?: string[];
}): string {
	const allowedOrigins = resolveAllowedOrigins(params.allowedOrigins);
	const bucketBinding =
		params.config.storage?.bucketBinding ?? "APPFLARE_STORAGE";
	const r2Buckets = params.config.storage
		? [
				{
					binding: bucketBinding,
					bucket_name: toBucketName(bucketBinding),
				},
			]
		: undefined;

	const wrangler: Record<string, unknown> = {
		$schema: "node_modules/wrangler/config-schema.json",
		name: sanitizeWorkerName(params.configDirAbs),
		main: "./server/index.ts",
		compatibility_date: new Date().toISOString().slice(0, 10),
		compatibility_flags: [
			"nodejs_compat",
			"nodejs_compat_populate_process_env",
		],
		migrations: [
			{ new_sqlite_classes: ["WebSocketHibernationServer"], tag: "v1" },
			{ new_sqlite_classes: ["MONGO_DURABLE_OBJECT"], tag: "v2" },
		],
		durable_objects: {
			bindings: [
				{
					class_name: "WebSocketHibernationServer",
					name: "WEBSOCKET_HIBERNATION_SERVER",
				},
				{ class_name: "MONGO_DURABLE_OBJECT", name: "MONGO_DURABLE_OBJECT" },
			],
		},
		observability: { enabled: true },
		placement: { mode: "smart" },
		vars: {
			ALLOWED_ORIGINS: allowedOrigins.join(","),
		},
	};

	if (r2Buckets && r2Buckets.length > 0) {
		wrangler.r2_buckets = r2Buckets;
	}

	return `${JSON.stringify(wrangler, null, 2)}\n`;
}
