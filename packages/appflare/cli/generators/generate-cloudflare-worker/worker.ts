import { resolveAllowedOrigins } from "./helpers";

export function generateCloudflareWorkerIndex(params: {
	allowedOrigins?: string[];
	hasCronHandlers?: boolean;
}): string {
	const allowedOrigins = resolveAllowedOrigins(params.allowedOrigins);
	const allowedOriginsCsv = allowedOrigins.join(",");
	const cronImports = params.hasCronHandlers
		? 'import { handleCron } from "./cron";\n'
		: "";
	const scheduledBlock = params.hasCronHandlers
		? `\n\tasync scheduled(controller, env, ctx): Promise<void> {\n\t\tawait handleCron({ controller, env, ctx });\n\t},\n`
		: "";

	return `/* eslint-disable */
/**
 * This file is auto-generated by the Appflare CLI.
 * Do not edit directly.
 */

import { createAppflareHonoServer } from "./server";
import { WebSocketHibernationServer } from "./websocket-hibernation-server";
import { createScheduler, handleSchedulerBatch } from "./scheduler";
${cronImports}import type { Hono } from "hono";
import { cors } from "hono/cors";

type DurableObjectNamespaceLike = {
	idFromName(name: string): any;
	get(id: any): { fetch(input: any, init?: RequestInit): Promise<Response> };
};

type Env = {
	WEBSOCKET_HIBERNATION_SERVER: DurableObjectNamespaceLike;
	APPFLARE_STORAGE?: unknown;
	ALLOWED_ORIGINS?: string;
	APPFLARE_SCHEDULER_QUEUE?: {
		send: (body: unknown, options?: { delaySeconds?: number }) => Promise<void>;
	};
};

type WorkerEnv = { Bindings: Env };

const parseAllowedOrigins = (value?: string | null): string[] =>
	(value ?? ${JSON.stringify(allowedOriginsCsv)})
		.split(",")
		.map((origin) => origin.trim())
		.filter(Boolean);

const resolveCorsOrigin = (
	origin: string | null,
	allowed: string[]
): string | undefined => {
	if (!origin) return undefined;
	if (allowed.includes("*")) return origin;
	return allowed.includes(origin) ? origin : undefined;
};

export default {
	async fetch(request, env, ctx): Promise<Response> {
		const allowedOrigins = parseAllowedOrigins(env.ALLOWED_ORIGINS);
		const resolveOrigin = (origin: string | null) =>
			resolveCorsOrigin(origin, allowedOrigins);
		const scheduler = env.APPFLARE_SCHEDULER_QUEUE
			? createScheduler(env.APPFLARE_SCHEDULER_QUEUE)
			: undefined;

		const app = createAppflareHonoServer({
			db: {} as any,
			corsOrigin: allowedOrigins,
			realtime: {
				durableObject: env.WEBSOCKET_HIBERNATION_SERVER,
				durableObjectName: "primary",
				notify: async (payload) => {
					const id = env.WEBSOCKET_HIBERNATION_SERVER.idFromName("primary");
					const stub = env.WEBSOCKET_HIBERNATION_SERVER.get(id);
					await stub.fetch("http://appflare-realtime/notify", {
						method: "POST",
						headers: { "content-type": "application/json" },
						body: JSON.stringify(payload),
					});
				},
			},
			scheduler,
		}) as unknown as Hono<WorkerEnv>;

		app.use(
			"*",
			cors({
				origin: resolveOrigin,
				credentials: true,
				allowMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
				allowHeaders: ["Content-Type", "Authorization", "Cookie"],
				exposeHeaders: ["set-cookie"],
			})
		);

		const origin = request.headers.get("Origin");
		const allowedOrigin = resolveOrigin(origin);
		if (request.method === "OPTIONS") {
			return new Response(null, {
				status: 204,
				headers: {
					"Access-Control-Allow-Origin": allowedOrigin ?? "",
					"Access-Control-Allow-Credentials": "true",
					"Access-Control-Allow-Methods": "GET,POST,PUT,DELETE,OPTIONS",
					"Access-Control-Allow-Headers":
						request.headers.get("Access-Control-Request-Headers") ??
						"Content-Type, Authorization, Cookie",
					Vary: "Origin",
				},
			});
		}

		const upgradeHeader = request.headers.get("Upgrade");
		if (upgradeHeader === "websocket") {
			const url = new URL(request.url);
			if (url.pathname === "/ws") {
				const id = env.WEBSOCKET_HIBERNATION_SERVER.idFromName("primary");
				const stub = env.WEBSOCKET_HIBERNATION_SERVER.get(id);
				return stub.fetch(request);
			}
		}

		const response = await app.fetch(request, env, ctx);
		if (allowedOrigin) {
			response.headers.set("Access-Control-Allow-Origin", allowedOrigin);
			response.headers.set("Access-Control-Allow-Credentials", "true");
			response.headers.append("Vary", "Origin");
		}
		return response;
	},

${scheduledBlock}
	async queue(batch, env): Promise<void> {
		await handleSchedulerBatch({ batch, env });
	},
} satisfies ExportedHandler<Env>;

export { WebSocketHibernationServer };
`;
}
