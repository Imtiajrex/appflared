export type ServerTemplateParams = {
	schemaImportPath: string;
	configImportLine: string;
	handlerImports: string[];
	authImports: string;
	authSetupBlock: string;
	authMountBlock: string;
	authResolverBlock: string;
	routeLines: string[];
	httpLines: string[];
};

export function renderServerTemplate(params: ServerTemplateParams): string {
	const authImportBlock = params.authImports ? `\n${params.authImports}\n` : "";
	const handlerImportBlock = params.handlerImports.join("\n");

	return `/* eslint-disable */
/**
 * This file is auto-generated by appflare/handler-build.ts.
 * Do not edit directly.
 */

import { Hono } from "hono";
import type { Context as HonoContext } from "hono";
import { sValidator } from "@hono/standard-validator";
import { z } from "zod";
import { cors } from "hono/cors";
import schema from ${JSON.stringify(params.schemaImportPath)};
${params.configImportLine}
import {
	createAppflareDbContext as createAppflareDbContextCore,
	type AppflareDbContext as AppflareDbContextType,
} from "appflare/server/db";
import {
	createR2StorageManager,
	type StorageManagerOptions,
} from "appflare/server/storage";${authImportBlock}
import { createD1MigrationRouter } from "appflare/server/d1";
import type {
	AppflareAuthContext,
	AppflareAuthSession,
	AppflareAuthUser,
	TableDocMap,
	TableNames,
	Scheduler,
} from "../src/schema-types";

${handlerImportBlock}

export type AppflareDbContext = AppflareDbContextType<TableNames, TableDocMap>;

export type AppflareServerContext = AppflareAuthContext & {
	db: AppflareDbContext;
	scheduler?: Scheduler;
	error: AppflareErrorFactory;
};

export type AppflareHandlerError = Error & {
	status: number;
	details?: unknown;
	__appflareHandlerError: true;
};

export type AppflareErrorFactory = (
	status: number,
	message?: string,
	details?: unknown
) => AppflareHandlerError;

const createHandlerError: AppflareErrorFactory = (
	status,
	message,
	details
) => {
	const err = new Error(message ?? \`HTTP \${status}\`);
	err.name = "AppflareHandlerError";
	const typed = err as AppflareHandlerError;
	typed.status = status;
	typed.details = details;
	typed.__appflareHandlerError = true;
	return typed;
};

const isHandlerError = (value: unknown): value is AppflareHandlerError =>
	!!value &&
	typeof value === "object" &&
	(value as any).__appflareHandlerError === true &&
	Number.isFinite((value as any).status);

const handlerErrorBody = (
	err: AppflareHandlerError
): { error: string; details?: unknown } => {
	const includeDetails =
		err.details !== undefined &&
		(err.details && typeof err.details === "object"
			? !(err.details instanceof Error) && !Array.isArray(err.details)
			: true);
	return includeDetails
		? { error: err.message, details: err.details }
		: { error: err.message };
};

async function runHandlerWithMiddleware<TArgs, TResult>(
	handler: {
		handler: (ctx: AppflareServerContext, args: TArgs) => Promise<TResult>;
		middleware?: (
			ctx: AppflareServerContext,
			args: TArgs
		) => Promise<TResult | void>;
	},
	ctx: AppflareServerContext,
	args: TArgs
): Promise<TResult> {
	if (handler.middleware) {
		const middlewareResult = await handler.middleware(ctx, args);
		if (typeof middlewareResult !== "undefined") {
			return middlewareResult as TResult;
		}
	}
	return handler.handler(ctx, args);
}

export function createAppflareDbContext(params: {
	collectionName?: (table: TableNames) => string;
	d1?: unknown;
}): AppflareDbContext {
	return createAppflareDbContextCore<TableNames, TableDocMap>({
		schema,
		collectionName: params.collectionName,
		d1: params.d1 as any,
	});
}

export type MutationNotification = {
	table: TableNames;
	handler: { file: string; name: string };
	args: unknown;
	result: unknown;
};

type DurableObjectNamespaceLike = {
	idFromName(name: string): any;
	get(id: any): { fetch(input: any, init?: RequestInit): Promise<Response> };
};

type MutationNotifier = (payload: MutationNotification) => Promise<void>;

type RealtimeOptions = {
	notify?: MutationNotifier;
	durableObject?: DurableObjectNamespaceLike;
	durableObjectName?: string;
};

type StorageOptions<Env = unknown, Principal = unknown> =
	Partial<StorageManagerOptions<Env, Principal>> & {
		enabled?: boolean;
		corsOrigin?: string | string[];
		corsAllowHeaders?: string[];
		corsAllowMethods?: string[];
	};

export type AppflareHonoServerOptions = {
	/** D1 database binding. Defaults to env.DB when available. */
	d1?: unknown;
	/** Configure auto-mounted migration endpoint for D1 + Better Auth. */
	migrations?: {
		enabled?: boolean;
		path?: string;
		includeSchema?: boolean;
		includeAuth?: boolean;
	};
	/** Provide a scheduler instance for enqueueing background work. */
	scheduler?: Scheduler;
	/** Provide a per-request scheduler instance (e.g. derived from env bindings). */
	getScheduler?: (c: HonoContext) => Scheduler | Promise<Scheduler>;
	/** Optionally extend the context beyond the db wrapper. */
	createContext?: (
		c: HonoContext,
		db: AppflareDbContext,
		auth: AppflareAuthContext,
		scheduler?: Scheduler,
		error?: AppflareErrorFactory
	) => AppflareServerContext | Promise<AppflareServerContext>;
	collectionName?: (table: TableNames) => string;
	corsOrigin?: string | string[];
	realtime?: RealtimeOptions;
	storage?: StorageOptions;
	};

function normalizeTableName(table: string): TableNames {
	const tables = schema as Record<string, unknown>;
	if (tables[table]) return table as TableNames;
	const plural = table + "s";
	if (tables[plural]) return plural as TableNames;
	throw new Error("Unknown table: " + table);
}

function normalizeStorageBasePath(basePath?: string): string {
	if (!basePath) return "/storage";
	const withLeadingSlash = basePath.startsWith("/")
		? basePath
		: "/" + basePath;
	return withLeadingSlash.endsWith("/")
		? withLeadingSlash.slice(0, -1) || "/"
		: withLeadingSlash;
}

function formatHandlerError(err: unknown): {
	status: number;
	body: { error: string; details?: unknown };
} {
	if (isHandlerError(err)) {
		return { status: err.status, body: handlerErrorBody(err) };
	}
	const statusCandidate =
		typeof err === "object" && err !== null
			? Number((err as any).status ?? (err as any).statusCode)
			: undefined;
	const status = Number.isFinite(statusCandidate)
		? Number(statusCandidate)
		: 500;

	const message =
		err instanceof Error
			? err.message
			: typeof err === "string"
				? err
				: "Unknown error";
	const includeDetails =
		err && typeof err === "object" && !(err instanceof Error) && !Array.isArray(err);

	return {
		status,
		body: includeDetails ? { error: message, details: err } : { error: message },
	};
}

export function createAppflareHonoServer(options: AppflareHonoServerOptions): Hono {
	const resolveDb = async (c: HonoContext): Promise<AppflareDbContext> => {
		const d1 = (options as any).d1 ?? (c as any)?.env?.DB;
		return createAppflareDbContext({
			collectionName: options.collectionName,
			d1,
		});
	};

	const fixedScheduler = options.scheduler;
	const resolveScheduler = async (
		c: HonoContext
	): Promise<Scheduler | undefined> => {
		if (fixedScheduler) return fixedScheduler;
		if (!options.getScheduler) return undefined;
		return options.getScheduler(c);
	};

	const createContext =
		options.createContext ??
		((_c, db, auth, scheduler, error) =>
			({
				db,
				scheduler,
				error: error ?? createHandlerError,
				...auth,
			} as AppflareServerContext));
\tconst notifyMutation = createMutationNotifier(options.realtime);
\tconst app = new Hono();
\tapp.use(
\t\tcors({
\t\t\torigin: options.corsOrigin ?? "*",
\t\t})
\t);

\tconst storageOptions = options.storage ?? {};
\tconst storageConfig = (appflareConfig as any).storage;
\tconst storageRules = storageOptions.rules ?? storageConfig?.rules;
\tconst storageEnabled =
\t\t(storageOptions.enabled ?? true) && !!storageRules && storageRules.length > 0;

\tif (storageEnabled) {
\t\tconst storageBasePath = normalizeStorageBasePath(
\t\t\tstorageOptions.basePath ?? storageConfig?.basePath
\t\t);
\t\tconst storageManager = createR2StorageManager({
\t\t\tbasePath: storageBasePath,
\t\t\tbucketBinding:
\t\t\t\tstorageOptions.bucketBinding ??
\t\t\t\tstorageConfig?.bucketBinding ??
\t\t\t\t"APPFLARE_STORAGE",
\t\t\tdefaultCacheControl:
\t\t\t\tstorageOptions.defaultCacheControl ??
\t\t\t\tstorageConfig?.defaultCacheControl,
\t\t\tgetBucket: storageOptions.getBucket ?? storageConfig?.getBucket,
\t\t\trules: storageRules!,
\t\t});

\t\tapp.use(
\t\t\tstorageBasePath + "/*",
\t\t\tcors({
\t\t\t\torigin: storageOptions.corsOrigin ?? "*",
\t\t\t\tallowHeaders: storageOptions.corsAllowHeaders ?? ["*"],
\t\t\t\tallowMethods:
\t\t\t\t\tstorageOptions.corsAllowMethods ?? [
\t\t\t\t\t\t"GET",
\t\t\t\t\t\t"HEAD",
\t\t\t\t\t\t"PUT",
\t\t\t\t\t\t"POST",
\t\t\t\t\t\t"DELETE",
\t\t\t\t\t\t"OPTIONS",
\t\t\t\t\t],
\t\t\t}),
\t\t);

\t\tapp.route("/", storageManager);
\t}
	const migrationConfig = options.migrations ?? {};
	const migrationsEnabled = migrationConfig.enabled ?? true;
	if (migrationsEnabled) {
		const migrationRouter = createD1MigrationRouter({
			path: migrationConfig.path ?? "/migrate",
			schema:
				migrationConfig.includeSchema === false
					? undefined
					: (schema as any),
			getDb: (c) => (((options as any).d1 ?? (c as any)?.env?.DB) as any),
			getBetterAuthOptions:
				migrationConfig.includeAuth === false
					? undefined
					: async (_c, db) => {
						const authConfig = (appflareConfig as any).auth;
						if (
							!authConfig ||
							authConfig.enabled === false ||
							!authConfig.options
						) {
							throw new Error("Better Auth options are not configured");
						}
						return { ...authConfig.options, database: db } as any;
					},
		});
		app.route("/", migrationRouter);
	}
${params.authSetupBlock}${params.authMountBlock}${params.authResolverBlock}\tconst resolveContext = async (
		c: HonoContext
	): Promise<AppflareServerContext> => {
		const db = await resolveDb(c);
		const auth = await resolveAuthContext(c);
		const scheduler = await resolveScheduler(c);
		const error = createHandlerError;
		const ctx = await createContext(c, db, auth, scheduler, error);
		const merged = {
			db,
			scheduler,
			...auth,
			...(ctx ?? {}),
			error: (ctx as any)?.error ?? error,
		};
		return merged as AppflareServerContext;
	};

		${params.routeLines.join("\n\n\t")}

	${params.httpLines.join("\n\n\t")}

	return app;
}

function createMutationNotifier(
	options?: RealtimeOptions
): MutationNotifier | undefined {
\tif (!options) return undefined;
\tif (options.notify) return options.notify;
\tif (options.durableObject) {
\t\treturn async (payload: MutationNotification) => {
\t\t\tconst id = options.durableObject!.idFromName(
\t\t\t\toptions.durableObjectName ?? "primary"
\t\t\t);
\t\t\tconst stub = options.durableObject!.get(id);
\t\t\tawait stub.fetch("http://appflare-realtime/notify", {
\t\t\t\tmethod: "POST",
\t\t\t\theaders: { "content-type": "application/json" },
\t\t\t\tbody: JSON.stringify(payload),
\t\t\t});
\t\t};
\t}
\treturn undefined;
}

`;
}
