export type ServerTemplateParams = {
	schemaImportPath: string;
	configImportLine: string;
	handlerImports: string[];
	authImports: string;
	authSetupBlock: string;
	authMountBlock: string;
	authResolverBlock: string;
	routeLines: string[];
};

export function renderServerTemplate(params: ServerTemplateParams): string {
	const authImportBlock = params.authImports ? `\n${params.authImports}\n` : "";
	const handlerImportBlock = params.handlerImports.join("\n");

	return `/* eslint-disable */
/**
 * This file is auto-generated by appflare/handler-build.ts.
 * Do not edit directly.
 */

import { Hono } from "hono";
import type { Context as HonoContext } from "hono";
import { sValidator } from "@hono/standard-validator";
import { z } from "zod";
import { cors } from "hono/cors";
import schema from ${JSON.stringify(params.schemaImportPath)};
${params.configImportLine}
import {
\tcreateMongoDbContext,
\ttype MongoDbContext,
} from "appflare/server/db";
import {
\tcreateR2StorageManager,
\ttype StorageManagerOptions,
} from "appflare/server/storage";${authImportBlock}
import type {
\tAppflareAuthContext,
\tAppflareAuthSession,
\tAppflareAuthUser,
\tTableDocMap,
\tTableNames,
\tScheduler,
} from "../src/schema-types";

${handlerImportBlock}

export type AppflareDbContext = MongoDbContext<TableNames, TableDocMap>;

export type AppflareServerContext = AppflareAuthContext & {
	db: AppflareDbContext;
	scheduler?: Scheduler;
	error: AppflareErrorFactory;
};

export type AppflareHandlerError = Error & {
	status: number;
	details?: unknown;
	__appflareHandlerError: true;
};

export type AppflareErrorFactory = (
	status: number,
	message?: string,
	details?: unknown
) => AppflareHandlerError;

const createHandlerError: AppflareErrorFactory = (
	status,
	message,
	details
) => {
	const err = new Error(message ?? \`HTTP \${status}\`);
	err.name = "AppflareHandlerError";
	const typed = err as AppflareHandlerError;
	typed.status = status;
	typed.details = details;
	typed.__appflareHandlerError = true;
	return typed;
};

const isHandlerError = (value: unknown): value is AppflareHandlerError =>
	!!value &&
	typeof value === "object" &&
	(value as any).__appflareHandlerError === true &&
	Number.isFinite((value as any).status);

const handlerErrorBody = (
	err: AppflareHandlerError
): { error: string; details?: unknown } => {
	const includeDetails =
		err.details !== undefined &&
		(err.details && typeof err.details === "object"
			? !(err.details instanceof Error) && !Array.isArray(err.details)
			: true);
	return includeDetails
		? { error: err.message, details: err.details }
		: { error: err.message };
};

async function runHandlerWithMiddleware<TArgs, TResult>(
	handler: {
		handler: (ctx: AppflareServerContext, args: TArgs) => Promise<TResult>;
		middleware?: (
			ctx: AppflareServerContext,
			args: TArgs
		) => Promise<TResult | void>;
	},
	ctx: AppflareServerContext,
	args: TArgs
): Promise<TResult> {
	if (handler.middleware) {
		const middlewareResult = await handler.middleware(ctx, args);
		if (typeof middlewareResult !== "undefined") {
			return middlewareResult as TResult;
		}
	}
	return handler.handler(ctx, args);
}

export function createAppflareDbContext(params: {
\tdb: import("mongodb").Db;
\tcollectionName?: (table: TableNames) => string;
}): AppflareDbContext {
\treturn createMongoDbContext<TableNames, TableDocMap>({
\t\tdb: params.db,
\t\tschema,
\t\tcollectionName: params.collectionName,
\t});
}

export type MutationNotification = {
\ttable: TableNames;
\thandler: { file: string; name: string };
\targs: unknown;
\tresult: unknown;
};

type DurableObjectNamespaceLike = {
\tidFromName(name: string): any;
\tget(id: any): { fetch(input: any, init?: RequestInit): Promise<Response> };
};

type MutationNotifier = (payload: MutationNotification) => Promise<void>;

type RealtimeOptions = {
\tnotify?: MutationNotifier;
\tdurableObject?: DurableObjectNamespaceLike;
\tdurableObjectName?: string;
};

type StorageOptions<Env = unknown, Principal = unknown> =
\tPartial<StorageManagerOptions<Env, Principal>> & {
\t\tenabled?: boolean;
\t\tcorsOrigin?: string | string[];
\t\tcorsAllowHeaders?: string[];
\t\tcorsAllowMethods?: string[];
\t};

export type AppflareHonoServerOptions = {
\t/** Provide a static Mongo Db instance. If omitted, set getDb instead. */
\tdb?: import("mongodb").Db;
\t/** Provide a per-request Mongo Db instance (e.g. from Cloudflare env bindings). */
\tgetDb?: (c: HonoContext) => import("mongodb").Db | Promise<import("mongodb").Db>;
	/** Provide a scheduler instance for enqueueing background work. */
	scheduler?: Scheduler;
	/** Provide a per-request scheduler instance (e.g. derived from env bindings). */
	getScheduler?: (c: HonoContext) => Scheduler | Promise<Scheduler>;
\t/** Optionally extend the context beyond the db wrapper. */
	createContext?: (
		c: HonoContext,
		db: AppflareDbContext,
		auth: AppflareAuthContext,
		scheduler?: Scheduler,
		error?: AppflareErrorFactory
	) => AppflareServerContext | Promise<AppflareServerContext>;
\tcollectionName?: (table: TableNames) => string;
\tcorsOrigin?: string | string[];
\trealtime?: RealtimeOptions;
\tstorage?: StorageOptions;
};

function normalizeTableName(table: string): TableNames {
\tconst tables = schema as Record<string, unknown>;
\tif (tables[table]) return table as TableNames;
\tconst plural = table + "s";
\tif (tables[plural]) return plural as TableNames;
\tthrow new Error("Unknown table: " + table);
}

function normalizeStorageBasePath(basePath?: string): string {
\tif (!basePath) return "/storage";
\tconst withLeadingSlash = basePath.startsWith("/")
\t\t? basePath
\t\t: "/" + basePath;
\treturn withLeadingSlash.endsWith("/")
\t\t? withLeadingSlash.slice(0, -1) || "/"
\t\t: withLeadingSlash;
}

function formatHandlerError(err: unknown): {
\tstatus: number;
\tbody: { error: string; details?: unknown };
} {
	if (isHandlerError(err)) {
		return { status: err.status, body: handlerErrorBody(err) };
	}
\tconst statusCandidate =
\t\ttypeof err === "object" && err !== null
\t\t\t? Number((err as any).status ?? (err as any).statusCode)
\t\t\t: undefined;
\tconst status = Number.isFinite(statusCandidate)
\t\t? Number(statusCandidate)
\t\t: 500;

\tconst message =
\t\terr instanceof Error
\t\t\t? err.message
\t\t\t: typeof err === "string"
\t\t\t\t? err
\t\t\t\t: "Unknown error";
\tconst includeDetails =
\t\terr && typeof err === "object" && !(err instanceof Error) && !Array.isArray(err);

\treturn {
\t\tstatus,
\t\tbody: includeDetails ? { error: message, details: err } : { error: message },
\t};
}

export function createAppflareHonoServer(options: AppflareHonoServerOptions): Hono {
\tconst fixedDb =
\t\toptions.db &&
\t\tcreateAppflareDbContext({
\t\t\tdb: options.db,
\t\t\tcollectionName: options.collectionName,
\t\t});

\tif (!fixedDb && !options.getDb) {
\t\tthrow new Error(
\t\t	"AppflareHonoServer requires either options.db or options.getDb to initialize the database context."
\t\t);
\t}

	const resolveDb = async (c: HonoContext): Promise<AppflareDbContext> => {
		if (fixedDb) return fixedDb;
		const db = await options.getDb!(c);
		return createAppflareDbContext({
			db,
			collectionName: options.collectionName,
		});
	};

	const fixedScheduler = options.scheduler;
	const resolveScheduler = async (
		c: HonoContext
	): Promise<Scheduler | undefined> => {
		if (fixedScheduler) return fixedScheduler;
		if (!options.getScheduler) return undefined;
		return options.getScheduler(c);
	};

	const createContext =
		options.createContext ??
		((_c, db, auth, scheduler, error) =>
			({
				db,
				scheduler,
				error: error ?? createHandlerError,
				...auth,
			} as AppflareServerContext));
\tconst notifyMutation = createMutationNotifier(options.realtime);
\tconst app = new Hono();
\tapp.use(
\t\tcors({
\t\t\torigin: options.corsOrigin ?? "*",
\t\t})
\t);

\tconst storageOptions = options.storage ?? {};
\tconst storageConfig = (appflareConfig as any).storage;
\tconst storageRules = storageOptions.rules ?? storageConfig?.rules;
\tconst storageEnabled =
\t\t(storageOptions.enabled ?? true) && !!storageRules && storageRules.length > 0;

\tif (storageEnabled) {
\t\tconst storageBasePath = normalizeStorageBasePath(
\t\t\tstorageOptions.basePath ?? storageConfig?.basePath
\t\t);
\t\tconst storageManager = createR2StorageManager({
\t\t\tbasePath: storageBasePath,
\t\t\tbucketBinding:
\t\t\t\tstorageOptions.bucketBinding ??
\t\t\t\tstorageConfig?.bucketBinding ??
\t\t\t\t"APPFLARE_STORAGE",
\t\t\tdefaultCacheControl:
\t\t\t\tstorageOptions.defaultCacheControl ??
\t\t\t\tstorageConfig?.defaultCacheControl,
\t\t\tgetBucket: storageOptions.getBucket ?? storageConfig?.getBucket,
\t\t\trules: storageRules!,
\t\t});

\t\tapp.use(
\t\t\tstorageBasePath + "/*",
\t\t\tcors({
\t\t\t\torigin: storageOptions.corsOrigin ?? "*",
\t\t\t\tallowHeaders: storageOptions.corsAllowHeaders ?? ["*"],
\t\t\t\tallowMethods:
\t\t\t\t\tstorageOptions.corsAllowMethods ?? [
\t\t\t\t\t\t"GET",
\t\t\t\t\t\t"HEAD",
\t\t\t\t\t\t"PUT",
\t\t\t\t\t\t"POST",
\t\t\t\t\t\t"DELETE",
\t\t\t\t\t\t"OPTIONS",
\t\t\t\t\t],
\t\t\t}),
\t\t);

\t\tapp.route("/", storageManager);
\t}
${params.authSetupBlock}${params.authMountBlock}${params.authResolverBlock}\tconst resolveContext = async (
		c: HonoContext
	): Promise<AppflareServerContext> => {
		const db = await resolveDb(c);
		const auth = await resolveAuthContext(c);
		const scheduler = await resolveScheduler(c);
		const error = createHandlerError;
		const ctx = await createContext(c, db, auth, scheduler, error);
		const merged = {
			db,
			scheduler,
			error,
			...auth,
			...(ctx ?? {}),
			error: (ctx as any)?.error ?? error,
		};
		return merged as AppflareServerContext;
	};

\t${params.routeLines.join("\n\n\t")}

\treturn app;
}

function createMutationNotifier(
\toptions?: RealtimeOptions
): MutationNotifier | undefined {
\tif (!options) return undefined;
\tif (options.notify) return options.notify;
\tif (options.durableObject) {
\t\treturn async (payload: MutationNotification) => {
\t\t\tconst id = options.durableObject!.idFromName(
\t\t\t\toptions.durableObjectName ?? "primary"
\t\t\t);
\t\t\tconst stub = options.durableObject!.get(id);
\t\t\tawait stub.fetch("http://appflare-realtime/notify", {
\t\t\t\tmethod: "POST",
\t\t\t\theaders: { "content-type": "application/json" },
\t\t\t\tbody: JSON.stringify(payload),
\t\t\t});
\t\t};
\t}
\treturn undefined;
}

`;
}
