import { promises as fs } from "node:fs";
import path from "node:path";
import { pascalCase } from "../utils/utils";

export async function generateDbHandlers(params: {
	outDirAbs: string;
	tableNames: string[];
}): Promise<void> {
	const handlersDir = path.join(params.outDirAbs, "src", "handlers");
	await fs.mkdir(handlersDir, { recursive: true });

	// Clean existing handler files to avoid stale tables lingering.
	const existing = await fs.readdir(handlersDir).catch(() => [] as string[]);
	await Promise.all(
		existing
			.filter((name) => name.endsWith(".ts"))
			.map((name) =>
				fs.unlink(path.join(handlersDir, name)).catch(() => void 0)
			)
	);

	const exportLines: string[] = [];
	for (const tableName of params.tableNames) {
		const pascal = pascalCase(tableName);
		const findFn = `find${pascal}`;
		const findOneFn = `findOne${pascal}`;
		const insertFn = `insert${pascal}`;
		const updateFn = `update${pascal}`;
		const deleteFn = `delete${pascal}`;
		const fileName = `${tableName}.ts`;
		const content = `/* eslint-disable */
/**
 * This file is auto-generated by appflare/db-build.ts.
 * Do not edit directly.
 */
import { z } from "zod";
import {
	internalMutation,
	internalQuery,
	type EditableDoc,
	type Id,
	type QuerySort,
	type QueryWhere,
} from "../schema-types";

export const ${findFn} = internalQuery({
	args: {
		where: z.custom<QueryWhere<${JSON.stringify(tableName)}>>().optional(),
		sort: z.custom<QuerySort<${JSON.stringify(tableName)}>>().optional(),
		limit: z.number().int().nonnegative().optional(),
		offset: z.number().int().nonnegative().optional(),
	},
	handler: async (ctx, args) => {
		return ctx.db[${JSON.stringify(tableName)} as any].findMany({
			where: args.where as any,
			orderBy: args.sort as any,
			skip: args.offset,
			take: args.limit,
		});
	},
});

export const ${findOneFn} = internalQuery({
	args: {
		where: z.custom<QueryWhere<${JSON.stringify(tableName)}>>().optional(),
		sort: z.custom<QuerySort<${JSON.stringify(tableName)}>>().optional(),
		offset: z.number().int().nonnegative().optional(),
	},
	handler: async (ctx, args) => {
		return ctx.db[${JSON.stringify(tableName)} as any].findFirst({
			where: args.where as any,
			orderBy: args.sort as any,
			skip: args.offset,
			take: 1,
		});
	},
});

export const ${insertFn} = internalMutation({
	args: {
		value: z.custom<EditableDoc<${JSON.stringify(tableName)}>>(),
	},
	handler: async (ctx, args) => {
		return ctx.db[${JSON.stringify(tableName)} as any].create({
			data: args.value as any,
		});
	},
});

export const ${updateFn} = internalMutation({
	args: {
		id: z.custom<Id<${JSON.stringify(tableName)}>>().optional(),
		where: z.custom<QueryWhere<${JSON.stringify(tableName)}>>().optional(),
		partial: z.custom<Partial<EditableDoc<${JSON.stringify(tableName)}>>>(),
	},
	handler: async (ctx, args) => {
		const filter = (args.where ?? args.id) as any;
		if (!filter) {
			throw new Error("update requires either args.where or args.id");
		}
		await ctx.db[${JSON.stringify(tableName)} as any].update({
			where: filter,
			data: args.partial as any,
		});
	},
});

export const ${deleteFn} = internalMutation({
	args: {
		id: z.custom<Id<${JSON.stringify(tableName)}>>().optional(),
		where: z.custom<QueryWhere<${JSON.stringify(tableName)}>>().optional(),
	},
	handler: async (ctx, args) => {
		const filter = (args.where ?? args.id) as any;
		if (!filter) {
			throw new Error("delete requires either args.where or args.id");
		}
		await ctx.db[${JSON.stringify(tableName)} as any].delete({
			where: filter,
		});
	},
});
`;
		await fs.writeFile(path.join(handlersDir, fileName), content);
		exportLines.push(
			`export { ${findFn}, ${findOneFn}, ${insertFn}, ${updateFn}, ${deleteFn} } from "./${tableName}";`
		);
	}

	const indexTs = `/* eslint-disable */
/**
 * This file is auto-generated by appflare/db-build.ts.
 * Do not edit directly.
 */
${exportLines.join("\n")}
`;
	await fs.writeFile(path.join(handlersDir, "index.ts"), indexTs);
}
