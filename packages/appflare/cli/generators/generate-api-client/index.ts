import {
	DiscoveredHandler,
	groupBy,
	pascalCase,
	toImportPathFromGeneratedSrc,
} from "../../utils/utils";
import {
	generateMutationsClientLines,
	generateQueriesClientLines,
} from "./client";
import {
	generateMutationsTypeLines,
	generateQueriesTypeLines,
	generateTypeBlocks,
	generateInternalTypeLines,
} from "./types";
import { renderObjectKey } from "./utils";
import { extractClientConfig } from "./extract-configuration";

const HEADER_TEMPLATE = `/* eslint-disable */
/**
 * This file is auto-generated by appflare/handler-build.ts.
 * Do not edit directly.
 */

import fetch from "better-fetch";
import { z } from "zod";
import type { BetterAuthClientOptions } from "better-auth/client";
import { createAuthClient } from "better-auth/client";

import type {
	AnyValidator,
	InferQueryArgs,
	MutationDefinition,
	QueryArgsShape,
	QueryDefinition,
	InternalMutationContext,
	InternalMutationDefinition,
	InternalQueryContext,
	InternalQueryDefinition,
} from "./schema-types";
{{configImport}}
`;

const TYPE_DEFINITIONS_TEMPLATE = `
type AnyArgsShape = Record<string, AnyValidator>;

type AnyHandlerDefinition = QueryDefinition<AnyArgsShape, unknown> | MutationDefinition<AnyArgsShape, unknown>;

type Simplify<T> = { [K in keyof T]: T[K] };

type OptionalKeys<TArgs extends QueryArgsShape> = {
	[K in keyof TArgs]: TArgs[K] extends z.ZodOptional<any> | z.ZodDefault<any> ? K : never;
}[keyof TArgs];

type RequiredKeys<TArgs extends QueryArgsShape> = Exclude<keyof TArgs, OptionalKeys<TArgs>>;

type HandlerArgsFromShape<TArgs extends QueryArgsShape> = Simplify<
	Partial<Pick<InferQueryArgs<TArgs>, OptionalKeys<TArgs>>> &
		Pick<InferQueryArgs<TArgs>, RequiredKeys<TArgs>>
>;

type HandlerArgs<THandler extends AnyHandlerDefinition> =
	THandler extends { args: infer TArgs extends QueryArgsShape }
		? HandlerArgsFromShape<TArgs>
		: never;

type HandlerResult<THandler extends AnyHandlerDefinition> = THandler extends {
	handler: (...args: any[]) => Promise<infer TResult>;
}
	? TResult
	: never;

type HandlerInvoker<TArgs, TResult> = (args: TArgs, init?: RequestInit) => Promise<TResult>;

type HandlerArgsShape<THandler extends AnyHandlerDefinition> =
	THandler extends { args: infer TArgs extends QueryArgsShape }
		? TArgs
		: never;

type HandlerSchemaFromShape<TArgs extends QueryArgsShape> = z.ZodObject<{
	[K in keyof TArgs]: z.ZodType<InferQueryArgs<TArgs>[K]>;
}>;

type HandlerSchema<THandler extends AnyHandlerDefinition> = HandlerSchemaFromShape<
	HandlerArgsShape<THandler>
>;

type WebSocketHeaders = Record<string, string>;

type WebSocketFactoryOptions = { headers?: WebSocketHeaders };

type WebSocketFactory = (
	url: string,
	protocols?: string | string[],
	options?: WebSocketFactoryOptions
) => WebSocket;

export type RealtimeMessage<TResult> = {
	type?: string;
	data?: TResult[];
	table?: string;
	where?: unknown;
	[key: string]: unknown;
};

export type HandlerWebsocketOptions<TResult> = {
	baseUrl?: string;
	table?: string;
	handler?: { file: string; name: string };
	handlerFile?: string;
	handlerName?: string;
	where?: Record<string, unknown>;
	orderBy?: Record<string, unknown>;
	take?: number;
	skip?: number;
	path?: string;
	protocols?: string | string[];
	headers?: WebSocketHeaders;
	signal?: AbortSignal;
	websocketImpl?: WebSocketFactory;
	onOpen?: (event: any) => void;
	onClose?: (event: any) => void;
	onError?: (event: any) => void;
	onMessage?: (message: RealtimeMessage<TResult>, raw: any) => void;
	onData?: (data: TResult[], message: RealtimeMessage<TResult>) => void;
};

type HandlerMetadata<THandler extends AnyHandlerDefinition> = {
	schema: HandlerSchema<THandler>;
	websocket: HandlerWebsocket<
		HandlerArgs<THandler>,
		HandlerResult<THandler>
	>;
	path: string;
};

export type HandlerWebsocket<TArgs, TResult> = (
	args?: TArgs,
	options?: HandlerWebsocketOptions<TResult>
) => WebSocket;

export type AppflareHandler<THandler extends AnyHandlerDefinition> = HandlerInvoker<
	HandlerArgs<THandler>,
	HandlerResult<THandler>
> &
	HandlerMetadata<THandler>;

export type StoragePutResult = {
	key: string;
	size: number;
	contentType: string;
	cacheControl: string;
};

export type StorageDeleteResult = {
	key: string;
	deleted: boolean;
};

export type StorageManagerClient = {
	url: (path: string) => string;
	get: (path: string, init?: RequestInit) => Promise<Response>;
	head: (path: string, init?: RequestInit) => Promise<Response>;
	put: (
		path: string,
		body: BodyInit,
		init?: RequestInit
	) => Promise<StoragePutResult>;
	post: (
		path: string,
		body: BodyInit,
		init?: RequestInit
	) => Promise<StoragePutResult>;
	delete: (path: string, init?: RequestInit) => Promise<StorageDeleteResult>;
};

export type StorageManagerOptions = {
	basePath?: string;
};

type RequestExecutor = (
	input: RequestInfo | URL,
	init?: RequestInit
) => Promise<Response>;

const defaultFetcher: RequestExecutor = (input, init) => fetch(input, init);

const defaultWebSocketFactory: WebSocketFactory = (
	url,
	protocols,
	_options
) => {
	if (typeof WebSocket === "undefined") {
		throw new Error(
			"WebSocket is not available in this environment. Provide options.realtime.websocketImpl to create websockets."
		);
	}
	return new WebSocket(url, protocols);
};

type ResolvedRealtimeConfig = {
	baseUrl?: string;
	path: string;
	headers?: WebSocketHeaders;
	websocketImpl?: WebSocketFactory;
};

type RealtimeConfig = {
	baseUrl?: string;
	path?: string;
	headers?: WebSocketHeaders;
	websocketImpl?: WebSocketFactory;
};

`;

const INTERNAL_TEMPLATE = `
export type InternalQueries = {{internalQueriesTypeDef}};

export type InternalMutations = {{internalMutationsTypeDef}};

export type InternalHandlers = InternalQueries & InternalMutations;

export const internal: InternalHandlers = {{internalInit}};

const __internalQueries = [
{{internalQueriesMeta}}
];

const __internalMutations = [
{{internalMutationsMeta}}
];

type BoundInternalHandlers = {
	[F in keyof InternalHandlers]: {
		[N in keyof InternalHandlers[F]]: InternalHandlers[F][N] extends InternalQueryDefinition<
			infer TArgs,
			infer TResult
		>
			? (args: HandlerArgsFromShape<TArgs>) => Promise<TResult>
			: InternalHandlers[F][N] extends InternalMutationDefinition<
				infer TArgs,
				infer TResult
			>
				? (args: HandlerArgsFromShape<TArgs>) => Promise<TResult>
				: never;
	};
};

export type InternalCaller = {
	internal: BoundInternalHandlers;
	runQuery: <TArgs extends QueryArgsShape, TResult>(
		handler: InternalQueryDefinition<TArgs, TResult>,
		args: HandlerArgsFromShape<TArgs>
	) => Promise<TResult>;
	runMutation: <TArgs extends QueryArgsShape, TResult>(
		handler: InternalMutationDefinition<TArgs, TResult>,
		args: HandlerArgsFromShape<TArgs>
	) => Promise<TResult>;
};

export function createInternalCaller(
	ctx: InternalQueryContext | InternalMutationContext
): InternalCaller {
	const bound: Record<string, Record<string, any>> = {};
	for (const entry of __internalQueries) {
		(bound[entry.file] ||= {})[entry.name] = (args: any) =>
			runInternalQuery(ctx as any, entry.handler as any, args as any);
	}
	for (const entry of __internalMutations) {
		(bound[entry.file] ||= {})[entry.name] = (args: any) =>
			runInternalMutation(ctx as any, entry.handler as any, args as any);
	}
	return {
		internal: bound as BoundInternalHandlers,
		runQuery: (handler, args) =>
			runInternalQuery(ctx as any, handler as any, args as any),
		runMutation: (handler, args) =>
			runInternalMutation(ctx as any, handler as any, args as any),
	};
}
`;

const CLIENT_TYPES_TEMPLATE = `
export type QueriesClient = {{queriesTypeDef}};

export type MutationsClient = {{mutationsTypeDef}};

{{authClientTypeDefinitions}}

export type AppflareApiClient = {
	queries: QueriesClient;
	mutations: MutationsClient;
	storage: StorageManagerClient;
	auth?: AppflareAuthClient;
};

export type AppflareApiOptions = {
	baseUrl?: string;
	fetcher?: RequestExecutor;
	realtime?: RealtimeConfig;
	storage?: StorageManagerOptions;
	auth?: (BetterAuthClientOptions & { baseURL?: string });
};

export function createAppflareApi(options: AppflareApiOptions = {}) {
	const baseUrl = normalizeBaseUrl(options.baseUrl);
	const request = options.fetcher ?? defaultFetcher;
	const realtime = resolveRealtimeConfig(baseUrl, options.realtime);
	const queries: QueriesClient = {{queriesInit}};
	const mutations: MutationsClient = {{mutationsInit}};
	const storage = createStorageManagerClient(baseUrl, request, options.storage);
	const authBasePath = normalizeAuthBasePath({{authBasePath}}) ?? "/auth";
{{authClientInit}}
	return { queries, mutations, storage, auth };
}

`;

const UTILITY_FUNCTIONS_TEMPLATE_PART1 = `
function withHandlerMetadata<THandler extends AnyHandlerDefinition>(
	invoke: HandlerInvoker<HandlerArgs<THandler>, HandlerResult<THandler>>,
	meta: HandlerMetadata<THandler>
): AppflareHandler<THandler> {
	const fn = invoke as AppflareHandler<THandler>;
	fn.schema = meta.schema;
	fn.websocket = meta.websocket;
	fn.path = meta.path;
	return fn;
}

function resolveRealtimeConfig(
	baseUrl: string,
	realtime?: RealtimeConfig
): ResolvedRealtimeConfig {
	return {
		baseUrl: normalizeWsBaseUrl(realtime?.baseUrl ?? baseUrl),
		path: realtime?.path ?? "/ws",
		headers: realtime?.headers,
		websocketImpl: realtime?.websocketImpl ?? defaultWebSocketFactory,
	};
}

function createHandlerSchema<TArgs extends QueryArgsShape>(
	args: TArgs
): HandlerSchemaFromShape<TArgs> {
	return z.object(args as any as Record<string, z.ZodTypeAny>) as HandlerSchemaFromShape<TArgs>;
}

function parseHandlerArgs<THandler extends AnyHandlerDefinition>(
	handler: THandler,
	args: HandlerArgs<THandler>
): HandlerArgs<THandler> {
	const schema = createHandlerSchema(handler.args as any);
	return schema.parse(args ?? ({} as HandlerArgs<THandler>)) as HandlerArgs<THandler>;
}

export async function runInternalQuery<
	TArgs extends QueryArgsShape,
	TResult,
>(
	ctx: InternalQueryContext,
	handler: InternalQueryDefinition<TArgs, TResult>,
	args: HandlerArgsFromShape<TArgs>
): Promise<TResult> {
	const parsed = parseHandlerArgs(handler as any, args as any);
	if (handler.middleware) {
		const middlewareResult = await handler.middleware(
			ctx as any,
			parsed as any
		);
		if (typeof middlewareResult !== "undefined") {
			return middlewareResult as TResult;
		}
	}
	return handler.handler(ctx as any, parsed as any);
}

export async function runInternalMutation<
	TArgs extends QueryArgsShape,
	TResult,
>(
	ctx: InternalMutationContext,
	handler: InternalMutationDefinition<TArgs, TResult>,
	args: HandlerArgsFromShape<TArgs>
): Promise<TResult> {
	const parsed = parseHandlerArgs(handler as any, args as any);
	if (handler.middleware) {
		const middlewareResult = await handler.middleware(
			ctx as any,
			parsed as any
		);
		if (typeof middlewareResult !== "undefined") {
			return middlewareResult as TResult;
		}
	}
	return handler.handler(ctx as any, parsed as any);
}

`;

const UTILITY_FUNCTIONS_TEMPLATE_PART2 = `
function createHandlerWebsocket<TArgs, TResult>(
	realtime: ResolvedRealtimeConfig,
	defaults: { defaultTable: string; defaultHandler: { file: string; name: string } }
): HandlerWebsocket<TArgs, TResult> {
	return (args, options) => {
		const baseUrl = normalizeWsBaseUrl(options?.baseUrl ?? realtime.baseUrl);
		if (!baseUrl) {
			throw new Error(
				"Missing realtime baseUrl. Provide createAppflareApi({ realtime: { baseUrl } }) or handler websocket options.baseUrl."
			);
		}
		const params = new URLSearchParams();
		const tableParam = options?.table ?? defaults.defaultTable;
		const normalizedTable = tableParam.endsWith("s")
			? tableParam
			: tableParam + "s";
		params.set("table", normalizedTable);

		const handlerRef =
			options?.handler ??
			(options?.handlerFile && options?.handlerName
				? { file: options.handlerFile, name: options.handlerName }
				: defaults.defaultHandler);
		if (handlerRef) {
			params.set("handler", JSON.stringify(handlerRef));
		}
		const where = options?.where ?? (isPlainObject(args) ? (args as Record<string, unknown>) : undefined);
		if (where && Object.keys(where).length > 0) {
			params.set("where", JSON.stringify(where));
		}
		if (options?.orderBy) params.set("orderBy", JSON.stringify(options.orderBy));
		if (options?.take !== undefined) params.set("take", String(options.take));
		if (options?.skip !== undefined) params.set("skip", String(options.skip));

		const path = options?.path ?? realtime.path;
		const url = buildRealtimeUrl(baseUrl, path, params);
		const websocketFactory = options?.websocketImpl ?? realtime.websocketImpl ?? defaultWebSocketFactory;
		const socket = websocketFactory(url, options?.protocols, {
			headers: options?.headers ?? realtime.headers,
		});

		if (options?.onOpen) socket.addEventListener("open", options.onOpen as any);
		if (options?.onClose) socket.addEventListener("close", options.onClose as any);
		if (options?.onError) socket.addEventListener("error", options.onError as any);

		const onMessage = (event: any) => {
			const message = parseRealtimeMessage<TResult>(event?.data ?? event);
			if (options?.onMessage) options.onMessage(message, event);
			if (message?.type === "data" && Array.isArray((message as any).data)) {
				options?.onData?.((message as any).data as TResult[], message);
			}
		};

		socket.addEventListener("message", onMessage as any);

		if (options?.signal) {
			const abortHandler = () => socket.close(1000, "aborted");
			if (options.signal.aborted) abortHandler();
			else options.signal.addEventListener("abort", abortHandler, { once: true });
		}

		return socket;
	};
}
`;

const UTILITY_FUNCTIONS_TEMPLATE_PART3 = `
function normalizeAuthBasePath(basePath?: string | null): string | undefined {
	if (!basePath) return undefined;
	const prefixed = basePath.startsWith("/") ? basePath : \`/\${basePath}\`;
	return prefixed.replace(/\\/+$/, "") || "/auth";
}

function normalizeBaseUrl(baseUrl?: string): string {
	if (!baseUrl) {
		return "";
	}
	return baseUrl.endsWith("/") ? baseUrl.slice(0, -1) : baseUrl;
}

function normalizeWsBaseUrl(baseUrl?: string): string | undefined {
	if (!baseUrl) return undefined;
	if (baseUrl.startsWith("ws://") || baseUrl.startsWith("wss://")) {
		return baseUrl.replace(/\\/+$/, "");
	}
	if (baseUrl.startsWith("https://")) return baseUrl.replace(/^https/, "wss").replace(/\\/$/, "");
	if (baseUrl.startsWith("http://")) return baseUrl.replace(/^http/, "ws").replace(/\\/$/, "");
	return baseUrl.replace(/\\/$/, "");
}

function buildUrl(baseUrl: string, path: string): string {
	if (!baseUrl) {
		return path;
	}
	const normalizedPath = path.startsWith("/") ? path : "/" + path;
	return baseUrl + normalizedPath;
}

function buildRealtimeUrl(
	baseUrl: string,
	path: string,
	params: URLSearchParams
): string {
	const normalizedBase = baseUrl.replace(/\\/+$/, "");
	const normalizedPath = path.startsWith("/") ? path : "/" + path;
	const query = params.toString();
	return query ? normalizedBase + normalizedPath + "?" + query : normalizedBase + normalizedPath;
}

function buildQueryUrl(
	baseUrl: string,
	path: string,
	params: Record<string, unknown> | undefined
): string {
	const url = buildUrl(baseUrl, path);
	const query = serializeQueryParams(params);
	return query ? url + "?" + query : url;
}

function serializeQueryParams(
	params: Record<string, unknown> | undefined
): string {
	if (!params) {
		return "";
	}
	const searchParams = new URLSearchParams();
	for (const [key, value] of Object.entries(params)) {
		if (value === undefined || value === null) {
			continue;
		}
		if (Array.isArray(value)) {
			for (const entry of value) {
				searchParams.append(key, serializeQueryValue(entry));
			}
			continue;
		}
		searchParams.append(key, serializeQueryValue(value));
	}
	return searchParams.toString();
}

function serializeQueryValue(value: unknown): string {
	if (value instanceof Date) {
		return value.toISOString();
	}
	if (typeof value === "object") {
		return JSON.stringify(value);
	}
	return String(value);
}

function normalizeStorageBasePath(basePath?: string): string {
	if (!basePath) return "/storage";
	const prefixed = basePath.startsWith("/") ? basePath : \`/\${basePath}\`;
	const trimmed = prefixed.replace(/\\/+$/, "");
	return trimmed || "/storage";
}

function buildStoragePath(basePath: string, path: string): string {
	const trimmedBase = basePath.endsWith("/") ? basePath.slice(0, -1) : basePath;
	const normalizedPath = path.startsWith("/") ? path : \`/\${path}\`;
	if (
		normalizedPath === trimmedBase ||
		normalizedPath.startsWith(\`\${trimmedBase}/\`)
	) {
		return normalizedPath;
	}
	return \`\${trimmedBase}\${normalizedPath}\`;
}

function createStorageManagerClient(
	baseUrl: string,
	request: RequestExecutor,
	options?: StorageManagerOptions
): StorageManagerClient {
	const basePath = normalizeStorageBasePath(options?.basePath);
	const toUrl = (path: string) => buildUrl(baseUrl, buildStoragePath(basePath, path));

	const sendJson = async <T>(
		method: string,
		path: string,
		init?: RequestInit
	): Promise<T> => {
		const response = await request(toUrl(path), { ...(init ?? {}), method });
		return parseJson<T>(response);
	};

	return {
		url: toUrl,
		get: (path, init) => request(toUrl(path), { ...(init ?? {}), method: "GET" }),
		head: (path, init) => request(toUrl(path), { ...(init ?? {}), method: "HEAD" }),
		put: (path, body, init) =>
			sendJson<StoragePutResult>("PUT", path, { ...(init ?? {}), body }),
		post: (path, body, init) =>
			sendJson<StoragePutResult>("POST", path, { ...(init ?? {}), body }),
		delete: (path, init) =>
			sendJson<StorageDeleteResult>("DELETE", path, { ...(init ?? {}) }),
	};
}

function isPlainObject(value: unknown): value is Record<string, unknown> {
	return !!value && typeof value === "object" && !Array.isArray(value);
}

function parseRealtimeMessage<TResult>(value: unknown): RealtimeMessage<TResult> {
	if (typeof value === "string") {
		try {
			return JSON.parse(value) as RealtimeMessage<TResult>;
		} catch {
			return { type: "message", raw: value } as any;
		}
	}
	return value as RealtimeMessage<TResult>;
}

function ensureJsonHeaders(headers?: HeadersInit): HeadersInit {
	if (!headers) {
		return { "content-type": "application/json" };
	}
	if (typeof Headers !== "undefined" && headers instanceof Headers) {
		const next = new Headers(headers);
		if (!next.has("content-type")) {
			next.set("content-type", "application/json");
		}
		return next;
	}
	if (Array.isArray(headers)) {
		const entries = headers.slice();
		const hasContentType = entries.some(
			([key]) => key.toLowerCase() === "content-type"
		);
		if (!hasContentType) {
			entries.push(["content-type", "application/json"]);
		}
		return entries;
	}
	if (typeof headers === "object") {
		const record = { ...(headers as Record<string, string>) };
		if (!hasHeader(record, "content-type")) {
			record["content-type"] = "application/json";
		}
		return record;
	}
	return { "content-type": "application/json" };
}

function hasHeader(record: Record<string, string>, name: string): boolean {
	const needle = name.toLowerCase();
	return Object.keys(record).some((key) => key.toLowerCase() === needle);
}

async function parseJson<TResult>(response: Response): Promise<TResult> {
	if (!response.ok) {
		throw new Error("Request failed with status " + response.status);
	}
	return (await response.json()) as TResult;
}
`;

const UTILITY_FUNCTIONS_TEMPLATE =
	UTILITY_FUNCTIONS_TEMPLATE_PART1 +
	UTILITY_FUNCTIONS_TEMPLATE_PART2 +
	UTILITY_FUNCTIONS_TEMPLATE_PART3;

function generateImports(params: {
	handlers: DiscoveredHandler[];
	outDirAbs: string;
}): { importLines: string[]; importAliasBySource: Map<string, string> } {
	const handlerImportsGrouped = groupBy(
		params.handlers,
		(h) => h.sourceFileAbs,
	);

	const importLines: string[] = [];
	const importAliasBySource = new Map<string, string>();
	for (const [fileAbs, list] of Array.from(handlerImportsGrouped.entries())) {
		const alias = `__appflare_${pascalCase(list[0].routePath)}`;
		importAliasBySource.set(fileAbs, alias);
		const importPath = toImportPathFromGeneratedSrc(params.outDirAbs, fileAbs);
		importLines.push(
			`import * as ${alias} from ${JSON.stringify(importPath)};`,
		);
	}
	return { importLines, importAliasBySource };
}

function generateGroupedHandlers(handlers: DiscoveredHandler[]): {
	queriesByFile: Map<string, DiscoveredHandler[]>;
	mutationsByFile: Map<string, DiscoveredHandler[]>;
	internalQueriesByFile: Map<string, DiscoveredHandler[]>;
	internalMutationsByFile: Map<string, DiscoveredHandler[]>;
} {
	const queries = handlers.filter((h) => h.kind === "query");
	const mutations = handlers.filter((h) => h.kind === "mutation");
	const internalQueries = handlers.filter((h) => h.kind === "internalQuery");
	const internalMutations = handlers.filter(
		(h) => h.kind === "internalMutation",
	);

	const queriesByFile = groupBy(queries, (h) => h.routePath);
	const mutationsByFile = groupBy(mutations, (h) => h.routePath);
	const internalQueriesByFile = groupBy(internalQueries, (h) => h.routePath);
	const internalMutationsByFile = groupBy(
		internalMutations,
		(h) => h.routePath,
	);

	return {
		queriesByFile,
		mutationsByFile,
		internalQueriesByFile,
		internalMutationsByFile,
	};
}

function generateTypeDefs(
	queriesByFile: Map<string, DiscoveredHandler[]>,
	mutationsByFile: Map<string, DiscoveredHandler[]>,
	internalQueriesByFile: Map<string, DiscoveredHandler[]>,
	internalMutationsByFile: Map<string, DiscoveredHandler[]>,
	importAliasBySource: Map<string, string>,
): {
	queriesTypeDef: string;
	mutationsTypeDef: string;
	internalQueriesTypeDef: string;
	internalMutationsTypeDef: string;
} {
	const queriesTypeLines = generateQueriesTypeLines(queriesByFile);
	const mutationsTypeLines = generateMutationsTypeLines(mutationsByFile);
	const internalQueriesTypeLines = generateInternalTypeLines(
		internalQueriesByFile,
		importAliasBySource,
	);
	const internalMutationsTypeLines = generateInternalTypeLines(
		internalMutationsByFile,
		importAliasBySource,
	);

	const queriesTypeDef =
		queriesByFile.size === 0 ? "{}" : `{\n${queriesTypeLines}\n}`;
	const mutationsTypeDef =
		mutationsByFile.size === 0 ? "{}" : `{\n${mutationsTypeLines}\n}`;
	const internalQueriesTypeDef =
		internalQueriesByFile.size === 0
			? "{}"
			: `{\n${internalQueriesTypeLines}\n}`;
	const internalMutationsTypeDef =
		internalMutationsByFile.size === 0
			? "{}"
			: `{\n${internalMutationsTypeLines}\n}`;

	return {
		queriesTypeDef,
		mutationsTypeDef,
		internalQueriesTypeDef,
		internalMutationsTypeDef,
	};
}

function generateClientInits(
	queriesByFile: Map<string, DiscoveredHandler[]>,
	mutationsByFile: Map<string, DiscoveredHandler[]>,
	importAliasBySource: Map<string, string>,
): { queriesInit: string; mutationsInit: string } {
	const queriesClientLines = generateQueriesClientLines(
		queriesByFile,
		importAliasBySource,
	);
	const mutationsClientLines = generateMutationsClientLines(
		mutationsByFile,
		importAliasBySource,
	);

	const queriesInit =
		queriesByFile.size === 0 ? "{}" : `{\n${queriesClientLines}\n\t}`;
	const mutationsInit =
		mutationsByFile.size === 0 ? "{}" : `{\n${mutationsClientLines}\n\t}`;

	return { queriesInit, mutationsInit };
}

function generateInternalInit(
	internalByFile: Map<string, DiscoveredHandler[]>,
	importAliasBySource: Map<string, string>,
): string {
	if (internalByFile.size === 0) return "{}";
	const lines: string[] = [];
	for (const [fileName, list] of Array.from(internalByFile.entries()).sort(
		(a, b) => a[0].localeCompare(b[0]),
	)) {
		const fileKey = renderObjectKey(fileName);
		const inner = list
			.slice()
			.sort((a, b) => a.name.localeCompare(b.name))
			.map((h) => {
				const alias = importAliasBySource.get(h.sourceFileAbs)!;
				return `\t\t${h.name}: ${alias}.${h.name},`;
			})
			.join("\n");
		lines.push(`\t${fileKey}: {\n${inner}\n\t}`);
	}
	return `{
${lines.join("\n")}
}`;
}

function generateInternalMeta(
	internalByFile: Map<string, DiscoveredHandler[]>,
	importAliasBySource: Map<string, string>,
): string {
	if (internalByFile.size === 0) return "";
	const lines: string[] = [];
	for (const [fileName, list] of Array.from(internalByFile.entries()).sort(
		(a, b) => a[0].localeCompare(b[0]),
	)) {
		for (const h of list.slice().sort((a, b) => a.name.localeCompare(b.name))) {
			const alias = importAliasBySource.get(h.sourceFileAbs)!;
			lines.push(
				`{ file: ${JSON.stringify(fileName)}, name: ${JSON.stringify(
					h.name,
				)}, handler: ${alias}.${h.name} },`,
			);
		}
	}
	return lines.join("\n");
}

export function generateApiClient(params: {
	handlers: DiscoveredHandler[];
	outDirAbs: string;
	authBasePath?: string;
	authEnabled?: boolean;
	configPathAbs?: string;
}): { apiTs: string; clientConfigTs: string | null } {
	const { importLines, importAliasBySource } = generateImports(params);
	const {
		queriesByFile,
		mutationsByFile,
		internalQueriesByFile,
		internalMutationsByFile,
	} = generateGroupedHandlers(params.handlers);
	const {
		queriesTypeDef,
		mutationsTypeDef,
		internalQueriesTypeDef,
		internalMutationsTypeDef,
	} = generateTypeDefs(
		queriesByFile,
		mutationsByFile,
		internalQueriesByFile,
		internalMutationsByFile,
		importAliasBySource,
	);
	const { queriesInit, mutationsInit } = generateClientInits(
		queriesByFile,
		mutationsByFile,
		importAliasBySource,
	);
	const internalHandlersCombined = new Map<string, DiscoveredHandler[]>();
	for (const [file, list] of Array.from(internalQueriesByFile.entries())) {
		internalHandlersCombined.set(file, list.slice());
	}
	for (const [file, list] of Array.from(internalMutationsByFile.entries())) {
		const existing = internalHandlersCombined.get(file) ?? [];
		internalHandlersCombined.set(file, existing.concat(list));
	}
	const internalInit = generateInternalInit(
		internalHandlersCombined,
		importAliasBySource,
	);
	const internalQueriesMeta = generateInternalMeta(
		internalQueriesByFile,
		importAliasBySource,
	);
	const internalMutationsMeta = generateInternalMeta(
		internalMutationsByFile,
		importAliasBySource,
	);

	const authBasePathLiteral = JSON.stringify(params.authBasePath ?? "/auth");

	// Generate config import and auth client options handling
	let configImport = "";
	let authClientTypeDefinitions =
		"type AppflareAuthClient = ReturnType<typeof createAuthClient>;";
	let authClientInit = `	const auth = createAuthClient({
			...(options.auth ?? {}),
			baseURL:
				(options.auth as any)?.baseURL ??
				buildUrl(baseUrl, authBasePath),
		});`;

	const clientConfigTs =
		params.authEnabled && params.configPathAbs
			? extractClientConfig(params.configPathAbs)
			: null;

	if (params.authEnabled && params.configPathAbs) {
		if (clientConfigTs) {
			configImport = `\nimport { clientOptions } from "./client.config";`;

			// Use a factory function pattern to properly infer the client type from clientOptions
			authClientTypeDefinitions = `const __getAppflareAuthClientOptions = () => (clientOptions ?? {}) as const;
type AppflareAuthClientOptions = ReturnType<typeof __getAppflareAuthClientOptions>;
const __createTypedAuthClient = (baseURL: string) => createAuthClient({
	...__getAppflareAuthClientOptions(),
	baseURL,
});
type AppflareAuthClient = ReturnType<typeof __createTypedAuthClient>;`;

			authClientInit = `	const auth =  createAuthClient({
			...__getAppflareAuthClientOptions(),
			...(options.auth ?? {}),
			baseURL:
				(options.auth as any)?.baseURL ??
				buildUrl(baseUrl, authBasePath),
		});`;
		} else {
			const configImportPath = toImportPathFromGeneratedSrc(
				params.outDirAbs,
				params.configPathAbs,
			);
			configImport = `\nimport __appflareConfig from ${JSON.stringify(configImportPath)};`;

			// Use a factory function pattern to properly infer the client type from clientOptions
			authClientTypeDefinitions = `const __getAppflareAuthClientOptions = () => (__appflareConfig.auth?.clientOptions ?? {}) as const;
type AppflareAuthClientOptions = ReturnType<typeof __getAppflareAuthClientOptions>;
const __createTypedAuthClient = (baseURL: string) => createAuthClient({
	...__getAppflareAuthClientOptions(),
	baseURL,
});
type AppflareAuthClient = ReturnType<typeof __createTypedAuthClient>;`;

			authClientInit = `	const auth =  createAuthClient({
			...__getAppflareAuthClientOptions(),
			...(options.auth ?? {}),
			baseURL:
				(options.auth as any)?.baseURL ??
				buildUrl(baseUrl, authBasePath),
		});`;
		}
	}

	const typeBlocks = generateTypeBlocks(params.handlers, importAliasBySource);

	return {
		apiTs:
			HEADER_TEMPLATE.replace("{{configImport}}", configImport) +
			importLines.join("\n") +
			TYPE_DEFINITIONS_TEMPLATE +
			typeBlocks.join("\n\n") +
			INTERNAL_TEMPLATE.replace(
				"{{internalQueriesTypeDef}}",
				internalQueriesTypeDef,
			)
				.replace("{{internalMutationsTypeDef}}", internalMutationsTypeDef)
				.replace("{{internalInit}}", internalInit)
				.replace("{{internalQueriesMeta}}", internalQueriesMeta)
				.replace("{{internalMutationsMeta}}", internalMutationsMeta) +
			CLIENT_TYPES_TEMPLATE.replace("{{queriesTypeDef}}", queriesTypeDef)
				.replace("{{mutationsTypeDef}}", mutationsTypeDef)
				.replace("{{queriesInit}}", queriesInit)
				.replace("{{mutationsInit}}", mutationsInit)
				.replace("{{authBasePath}}", authBasePathLiteral)
				.replace("{{authClientTypeDefinitions}}", authClientTypeDefinitions)
				.replace("{{authClientInit}}", authClientInit) +
			UTILITY_FUNCTIONS_TEMPLATE,
		clientConfigTs,
	};
}
