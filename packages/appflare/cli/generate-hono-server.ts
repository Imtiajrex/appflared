import {
	DiscoveredHandler,
	groupBy,
	pascalCase,
	toImportPathFromGeneratedServer,
} from "./utils";

export function generateHonoServer(params: {
	handlers: DiscoveredHandler[];
	outDirAbs: string;
	schemaPathAbs: string;
}): string {
	const queries = params.handlers.filter((h) => h.kind === "query");
	const mutations = params.handlers.filter((h) => h.kind === "mutation");
	const schemaImportPath = toImportPathFromGeneratedServer(
		params.outDirAbs,
		params.schemaPathAbs
	);

	const localNameFor = (h: DiscoveredHandler): string =>
		`__appflare_${pascalCase(h.fileName)}_${h.name}`;

	const grouped = groupBy(params.handlers, (h) => h.sourceFileAbs);
	const importLines: string[] = [];
	for (const [fileAbs, list] of Array.from(grouped.entries())) {
		const specifiers = list
			.slice()
			.sort((a, b) => a.name.localeCompare(b.name))
			.map((h) => `${h.name} as ${localNameFor(h)}`);
		const importPath = toImportPathFromGeneratedServer(
			params.outDirAbs,
			fileAbs
		);
		importLines.push(
			`import { ${specifiers.join(", ")} } from ${JSON.stringify(importPath)};`
		);
	}

	const routeLines: string[] = [];
	for (const q of queries) {
		const local = localNameFor(q);
		routeLines.push(
			`app.get(\n` +
				`\t${JSON.stringify(`/queries/${q.fileName}/${q.name}`)},\n` +
				`\tsValidator("query", z.object(${local}.args as any)),\n` +
				`\tasync (c) => {\n` +
				`\t\tconst query = c.req.valid("query");\n` +
				`\t\tconst ctx = await createContext(c);\n` +
				`\t\tconst result = await ${local}.handler(ctx as any, query as any);\n` +
				`\t\treturn c.json(result, 200);\n` +
				`\t}\n` +
				`);`
		);
	}
	for (const m of mutations) {
		const local = localNameFor(m);
		routeLines.push(
			`app.post(\n` +
				`\t${JSON.stringify(`/mutations/${m.fileName}/${m.name}`)},\n` +
				`\tsValidator("json", z.object(${local}.args as any)),\n` +
				`\tasync (c) => {\n` +
				`\t\tconst body = c.req.valid("json");\n` +
				`\t\tconst ctx = await createContext(c);\n` +
				`\t\tconst result = await ${local}.handler(ctx as any, body as any);\n` +
				`\t\treturn c.json(result, 200);\n` +
				`\t}\n` +
				`);`
		);
	}

	return `/* eslint-disable */
/**
 * This file is auto-generated by appflare/handler-build.ts.
 * Do not edit directly.
 */

import { Hono } from "hono";
import type { Context as HonoContext } from "hono";
import { sValidator } from "@hono/standard-validator";
import { z } from "zod";
import { cors } from "hono/cors";
import schema from ${JSON.stringify(schemaImportPath)};
import {
	createMongoDbContext,
	type MongoDbContext,
} from "appflare/server/db";

import type { TableDocMap, TableNames } from "../src/schema-types";

${importLines.join("\n")}

export type AppflareDbContext = MongoDbContext<TableNames, TableDocMap>;

export type AppflareServerContext = { db: AppflareDbContext };

export type AppflareHonoServerOptions = {
	/** Provide a static Mongo Db instance. If omitted, set getDb instead. */
	db?: import("mongodb").Db;
	/** Provide a per-request Mongo Db instance (e.g. from Cloudflare env bindings). */
	getDb?: (c: HonoContext) => import("mongodb").Db | Promise<import("mongodb").Db>;
	/** Optionally extend the context beyond the db wrapper. */
	createContext?: (
		c: HonoContext,
		db: AppflareDbContext
	) => AppflareServerContext | Promise<AppflareServerContext>;
	collectionName?: (table: TableNames) => string;
	corsOrigin?: string | string[];
};

export function createAppflareHonoServer(options: AppflareHonoServerOptions): Hono {
	const fixedDb =
		options.db &&
		createMongoDbContext<TableNames, TableDocMap>({
			db: options.db,
			schema,
			collectionName: options.collectionName,
		});

	if (!fixedDb && !options.getDb) {
		throw new Error(
			"AppflareHonoServer requires either options.db or options.getDb to initialize the database context."
		);
	}

	const resolveDb = async (c: HonoContext): Promise<AppflareDbContext> => {
		if (fixedDb) return fixedDb;
		const db = await options.getDb!(c);
		return createMongoDbContext<TableNames, TableDocMap>({
			db,
			schema,
			collectionName: options.collectionName,
		});
	};

	const createContext =
		options.createContext ?? ((_c, db) => ({ db } as AppflareServerContext));
	const app = new Hono();
	app.use(
		cors({
			origin: options.corsOrigin ?? "*",
		})
	);

	${routeLines
		.map((line) =>
			line.replace(
				"const ctx = await createContext(c);",
				"const db = await resolveDb(c);\n\t\tconst ctx = await createContext(c, db);"
			)
		)
		.join("\n\n\t")}

	return app;
}

const app = createAppflareHonoServer({
	getDb: () => {
		throw new Error(
			"AppflareHonoServer default export requires options.db or options.getDb. Provide one when creating the server."
		);
	},
});

export default app;
`;
}
