import { toImportPathFromGeneratedServer } from "./utils";

export function generateWebsocketDurableObject(params: {
	outDirAbs: string;
	schemaPathAbs: string;
}): string {
	const schemaImportPath = toImportPathFromGeneratedServer(
		params.outDirAbs,
		params.schemaPathAbs
	);
	const schemaTypesImportPath = "../src/schema-types";

	return `/* eslint-disable */
/**
 * This file is auto-generated by appflare/handler-build.ts.
 * Do not edit directly.
 */

import { DurableObject } from "cloudflare:workers";
import { getDatabase } from "cloudflare-do-mongo";
import { createMongoDbContext, type MongoDbContext } from "appflare/server/db";
import schema from ${JSON.stringify(schemaImportPath)};
import type {
	QueryWhere,
	QuerySort,
	TableDocMap,
	TableNames,
} from ${JSON.stringify(schemaTypesImportPath)};

export type MutationNotification = {
	table: TableNames;
	handler: { file: string; name: string };
	args: unknown;
	result?: unknown;
};

type Subscription = {
	table: TableNames;
	where?: QueryWhere<TableNames>;
	orderBy?: QuerySort<TableNames>;
	take?: number;
	skip?: number;
};

type ParsedSubscription =
	| { ok: true; value: Subscription }
	| { ok: false; error: string };

const resolveDatabase = (env: any) => {
	if (env?.DB) return env.DB as any;
	if (env?.MONGO_DB) return getDatabase(env.MONGO_DB) as any;
	throw new Error(
		"WebSocketHibernationServer requires either env.DB or env.MONGO_DB to be set."
	);
};

export class WebSocketHibernationServer extends DurableObject {
	private readonly env: any;
	private subscriptions: Map<WebSocket, Subscription>;
	private db: MongoDbContext<TableNames, TableDocMap> | null;

	constructor(ctx: DurableObjectState, env: any) {
		super(ctx, env);
		this.env = env;
		this.subscriptions = new Map();
		this.db = null;

		for (const socket of this.ctx.getWebSockets()) {
			const restored = socket.deserializeAttachment() as Subscription | undefined;
			if (restored) {
				this.subscriptions.set(socket, restored);
			}
		}

		this.ctx.setWebSocketAutoResponse(
			new WebSocketRequestResponsePair("ping", "pong")
		);
	}

	async fetch(request: Request): Promise<Response> {
		const url = new URL(request.url);
		const pathname = url.pathname;

		if (request.headers.get("Upgrade") === "websocket" && pathname === "/ws") {
			const parsed = this.parseSubscription(url.searchParams);
			if (!parsed.ok) {
				return new Response(parsed.error, { status: 400 });
			}
			return this.handleSubscribe(parsed.value);
		}

		if (pathname === "/notify" && request.method === "POST") {
			const payload = (await request.json().catch(() => null)) as
				| MutationNotification
				| null;
			if (!payload) {
				return new Response("Invalid mutation payload", { status: 400 });
			}
			await this.handleNotification(payload);
			return new Response("ok", { status: 200 });
		}

		return new Response("Not found", { status: 404 });
	}

	async webSocketMessage(
		ws: WebSocket,
		message: ArrayBuffer | string
	): Promise<void> {
		if (typeof message === "string" && message.toLowerCase() === "ping") {
			ws.send("pong");
			return;
		}
	}

	async webSocketClose(ws: WebSocket): Promise<void> {
		this.subscriptions.delete(ws);
	}

	private async handleSubscribe(sub: Subscription): Promise<Response> {
		const { 0: client, 1: server } = Object.values(new WebSocketPair());
		server.serializeAttachment(sub);
		this.ctx.acceptWebSocket(server);
		this.subscriptions.set(server, sub);
		server.send(
			JSON.stringify({ type: "subscribed", subscription: sub })
		);

		try {
			const data = await this.fetchData(sub);
			server.send(
				JSON.stringify({
					type: "data",
					table: sub.table,
					where: sub.where,
					data,
				})
			);
		} catch (err) {
			console.error("Failed to send initial payload", err);
		}

		return new Response(null, { status: 101, webSocket: client });
	}

	private parseSubscription(params: URLSearchParams): ParsedSubscription {
		const table = this.normalizeTableName(params.get("table"));
		if (!table) {
			return { ok: false, error: "Missing or invalid table param" };
		}

		const parseJson = <T>(key: string): T | undefined => {
			const raw = params.get(key);
			if (!raw) return undefined;
			try {
				return JSON.parse(raw) as T;
			} catch (err) {
				console.error(\`Failed to parse \${key} search param\`, err);
				return undefined;
			}
		};

		const where = parseJson<QueryWhere<TableNames>>("where");
		const orderBy = parseJson<QuerySort<TableNames>>("orderBy");
		const takeStr = params.get("take") ?? params.get("limit");
		const skipStr = params.get("skip") ?? params.get("offset");

		return {
			ok: true,
			value: {
				table,
				where,
				orderBy,
				take: takeStr ? Number(takeStr) : undefined,
				skip: skipStr ? Number(skipStr) : undefined,
			},
		};
	}

	private async handleNotification(
		payload: MutationNotification
	): Promise<void> {
		const matches = Array.from(this.subscriptions.entries()).filter(([, sub]) =>
			this.shouldNotify(sub, payload)
		);
		if (matches.length === 0) return;

		const cache = new Map<string, unknown[]>();
		for (const [, sub] of matches) {
			const key = this.subscriptionKey(sub);
			if (!cache.has(key)) {
				cache.set(key, await this.fetchData(sub));
			}
		}

		for (const [socket, sub] of matches) {
			const key = this.subscriptionKey(sub);
			const data = cache.get(key) ?? [];
			try {
				socket.send(
					JSON.stringify({
						type: "data",
						table: sub.table,
						where: sub.where,
						data,
					})
				);
			} catch (err) {
				socket.close(1011, "send failed");
				this.subscriptions.delete(socket);
				console.error("Failed to notify websocket, closing", err);
			}
		}
	}

	private shouldNotify(
		sub: Subscription,
		payload: MutationNotification
	): boolean {
		if (payload.table !== sub.table) return false;

		const doc = this.extractDocument(payload);
		if (doc && this.matchesWhere(sub.where, doc)) return true;

		const mutationWhere = this.extractWhere(payload.args);
		if (!sub.where) return true;
		if (this.whereIntersects(sub.where, mutationWhere)) return true;
		return false;
	}

	private extractDocument(payload: MutationNotification):
		| Record<string, unknown>
		| null {
		const result = payload.result as unknown;
		if (result && typeof result === "object" && !Array.isArray(result)) {
			return result as Record<string, unknown>;
		}
		const args = payload.args as any;
		if (args && typeof args === "object" && args.data && typeof args.data === "object") {
			return args.data as Record<string, unknown>;
		}
		return null;
	}

	private extractWhere(args: unknown): Record<string, unknown> | undefined {
		if (!args || typeof args !== "object") return undefined;
		const obj = args as Record<string, unknown>;
		if (obj.where && typeof obj.where === "object") {
			return obj.where as Record<string, unknown>;
		}
		if (obj.id) {
			return { _id: obj.id } as Record<string, unknown>;
		}
		return undefined;
	}

	private whereIntersects(
		subWhere?: Record<string, unknown>,
		mutationWhere?: Record<string, unknown>
	): boolean {
		if (!subWhere) return true;
		if (!mutationWhere) return false;
		for (const [key, value] of Object.entries(subWhere)) {
			if (value === undefined) continue;
			if (key in mutationWhere && mutationWhere[key] !== value) {
				return false;
			}
		}
		return true;
	}

	private matchesWhere(
		where: Record<string, unknown> | undefined,
		doc: Record<string, unknown>
	): boolean {
		if (!where) return true;
		for (const [key, expected] of Object.entries(where)) {
			if (expected === undefined) continue;
			const value = doc[key];
			if (Array.isArray(expected)) {
				if (!Array.isArray(value)) return false;
				for (const entry of expected) {
					if (!value.includes(entry)) return false;
				}
				continue;
			}
			if (expected !== value) return false;
		}
		return true;
	}

	private async fetchData(sub: Subscription): Promise<unknown[]> {
		const db = this.getDb();
		const table = db[sub.table] as any;
		if (!table || typeof table.findMany !== "function") {
			throw new Error(\`Unknown table: \${sub.table}\`);
		}
		const data = await table.findMany({
			where: sub.where as any,
			orderBy: sub.orderBy as any,
			skip: sub.skip,
			take: sub.take,
		});
		return data ?? [];
	}

	private getDb(): MongoDbContext<TableNames, TableDocMap> {
		if (!this.db) {
			this.db = createMongoDbContext<TableNames, TableDocMap>({
				db: resolveDatabase(this.env),
				schema,
			});
		}
		return this.db;
	}

	private subscriptionKey(sub: Subscription): string {
		return JSON.stringify({
			table: sub.table,
			where: sub.where ?? null,
			orderBy: sub.orderBy ?? null,
			take: sub.take ?? null,
			skip: sub.skip ?? null,
		});
	}

	private normalizeTableName(table: string | null): TableNames | null {
		if (!table) return null;
		const schemaTables = schema as Record<string, unknown>;
		if (schemaTables[table]) return table as TableNames;
		const plural = \`\${table}s\`;
		if (schemaTables[plural]) return plural as TableNames;
		return null;
	}
}
`;
}
