import { promises as fs } from "node:fs";
import path from "node:path";
import {
	DiscoveredHandler,
	HandlerKind,
	pascalCase,
	walkTsFiles,
	groupBy,
	toImportPathFromGeneratedSrc,
	toImportPathFromGeneratedServer,
} from "./utils";

export async function discoverHandlers(params: {
	projectDirAbs: string;
	schemaPathAbs: string;
	outDirAbs: string;
	configPathAbs: string;
}): Promise<DiscoveredHandler[]> {
	const ignoreDirs = new Set([
		"node_modules",
		".git",
		"dist",
		"build",
		path.basename(params.outDirAbs),
	]);

	const files = await walkTsFiles(params.projectDirAbs, ignoreDirs);

	const handlers: DiscoveredHandler[] = [];
	for (const fileAbs of files) {
		if (path.resolve(fileAbs) === path.resolve(params.schemaPathAbs)) continue;
		if (path.resolve(fileAbs) === path.resolve(params.configPathAbs)) continue;

		const content = await fs.readFile(fileAbs, "utf8");
		const regex =
			/export\s+const\s+([A-Za-z_$][\w$]*)\s*=\s*(query|mutation)\s*\(/g;
		let match: RegExpExecArray | null;
		while ((match = regex.exec(content)) !== null) {
			handlers.push({
				name: match[1],
				kind: match[2] as HandlerKind,
				sourceFileAbs: fileAbs,
			});
		}
	}

	// De-dupe: keep first occurrence
	const seen = new Set<string>();
	const unique = handlers.filter((h) => {
		const key = `${h.kind}:${h.name}`;
		if (seen.has(key)) return false;
		seen.add(key);
		return true;
	});

	unique.sort((a, b) => {
		if (a.kind !== b.kind) return a.kind.localeCompare(b.kind);
		return a.name.localeCompare(b.name);
	});

	return unique;
}

export async function generateDbHandlers(params: {
	outDirAbs: string;
	tableNames: string[];
}): Promise<void> {
	const handlersDir = path.join(params.outDirAbs, "src", "handlers");
	await fs.mkdir(handlersDir, { recursive: true });

	// Clean existing handler files to avoid stale tables lingering.
	const existing = await fs.readdir(handlersDir).catch(() => [] as string[]);
	await Promise.all(
		existing
			.filter((name) => name.endsWith(".ts"))
			.map((name) =>
				fs.unlink(path.join(handlersDir, name)).catch(() => void 0)
			)
	);

	const exportLines: string[] = [];
	for (const tableName of params.tableNames) {
		const pascal = pascalCase(tableName);
		const findFn = `find${pascal}`;
		const findOneFn = `findOne${pascal}`;
		const insertFn = `insert${pascal}`;
		const updateFn = `update${pascal}`;
		const deleteFn = `delete${pascal}`;
		const fileName = `${tableName}.ts`;
		const content = `/* eslint-disable */
/**
 * This file is auto-generated by appflare/db-build.ts.
 * Do not edit directly.
 */
import { z } from "zod";
import {
	mutation,
	query,
	type EditableDoc,
	type Id,
	type QuerySort,
	type QueryWhere,
} from "../schema-types";

export const ${findFn} = query({
	args: {
		where: z.custom<QueryWhere<${JSON.stringify(tableName)}>>().optional(),
		sort: z.custom<QuerySort<${JSON.stringify(tableName)}>>().optional(),
		limit: z.number().int().nonnegative().optional(),
		offset: z.number().int().nonnegative().optional(),
	},
	handler: async (ctx, args) => {
		let q = ctx.db.query(${JSON.stringify(tableName)} as any);
		if (args.where) q = q.where(args.where as any);
		if (args.sort) q = q.sort(args.sort as any);
		if (args.offset !== undefined) q = q.offset(args.offset);
		if (args.limit !== undefined) q = q.limit(args.limit);
		return q.find();
	},
});

export const ${findOneFn} = query({
	args: {
		where: z.custom<QueryWhere<${JSON.stringify(tableName)}>>().optional(),
		sort: z.custom<QuerySort<${JSON.stringify(tableName)}>>().optional(),
		offset: z.number().int().nonnegative().optional(),
	},
	handler: async (ctx, args) => {
		let q = ctx.db.query(${JSON.stringify(tableName)} as any);
		if (args.where) q = q.where(args.where as any);
		if (args.sort) q = q.sort(args.sort as any);
		if (args.offset !== undefined) q = q.offset(args.offset);
		return q.findOne();
	},
});

export const ${insertFn} = mutation({
	args: {
		value: z.custom<EditableDoc<${JSON.stringify(tableName)}>>(),
	},
	handler: async (ctx, args) => {
		return ctx.db.insert(${JSON.stringify(tableName)} as any, args.value as any);
	},
});

export const ${updateFn} = mutation({
	args: {
		id: z.custom<Id<${JSON.stringify(tableName)}>>(),
		partial: z.custom<Partial<EditableDoc<${JSON.stringify(tableName)}>>>(),
	},
	handler: async (ctx, args) => {
		if (typeof (ctx.db as any).update === "function") {
			await (ctx.db as any).update(
				${JSON.stringify(tableName)} as any,
				args.id as any,
				args.partial as any
			);
			return;
		}
		await ctx.db.patch(
			${JSON.stringify(tableName)} as any,
			args.id as any,
			args.partial as any
		);
	},
});

export const ${deleteFn} = mutation({
	args: {
		id: z.custom<Id<${JSON.stringify(tableName)}>>(),
	},
	handler: async (ctx, args) => {
		await ctx.db.delete(${JSON.stringify(tableName)} as any, args.id as any);
	},
});
`;
		await fs.writeFile(path.join(handlersDir, fileName), content);
		exportLines.push(
			`export { ${findFn}, ${findOneFn}, ${insertFn}, ${updateFn}, ${deleteFn} } from "./${tableName}";`
		);
	}

	const indexTs = `/* eslint-disable */
/**
 * This file is auto-generated by appflare/db-build.ts.
 * Do not edit directly.
 */
${exportLines.join("\n")}
`;
	await fs.writeFile(path.join(handlersDir, "index.ts"), indexTs);
}

export function generateApiClient(params: {
	handlers: DiscoveredHandler[];
	outDirAbs: string;
}): string {
	const queries = params.handlers.filter((h) => h.kind === "query");
	const mutations = params.handlers.filter((h) => h.kind === "mutation");

	const typeBlocks: string[] = [];
	for (const h of params.handlers) {
		const importPath = toImportPathFromGeneratedSrc(
			params.outDirAbs,
			h.sourceFileAbs
		);
		const pascal = pascalCase(h.name);
		typeBlocks.push(
			`type ${pascal}Definition = typeof import(${JSON.stringify(importPath)})[${JSON.stringify(h.name)}];\n` +
				`type ${pascal}Args = HandlerArgs<${pascal}Definition>;\n` +
				`type ${pascal}Result = HandlerResult<${pascal}Definition>;`
		);
	}

	const queriesClientLines = queries
		.map((h) => {
			const pascal = pascalCase(h.name);
			return (
				`\t${h.name}: async (args: ${pascal}Args, init) => {\n` +
				`\t\t\tconst url = buildQueryUrl(baseUrl, ${JSON.stringify(`/queries/${h.name}`)}, args);\n` +
				`\t\t\tconst response = await request(url, {\n` +
				`\t\t\t\t...(init ?? {}),\n` +
				`\t\t\t\tmethod: "GET",\n` +
				`\t\t\t});\n` +
				`\t\t\treturn parseJson<${pascal}Result>(response);\n` +
				`\t\t},`
			);
		})
		.join("\n");

	const mutationsClientLines = mutations
		.map((h) => {
			const pascal = pascalCase(h.name);
			return (
				`\t${h.name}: async (args: ${pascal}Args, init) => {\n` +
				`\t\t\tconst url = buildUrl(baseUrl, ${JSON.stringify(`/mutations/${h.name}`)});\n` +
				`\t\t\tconst response = await request(url, {\n` +
				`\t\t\t\t...(init ?? {}),\n` +
				`\t\t\t\tmethod: "POST",\n` +
				`\t\t\t\theaders: ensureJsonHeaders(init?.headers),\n` +
				`\t\t\t\tbody: JSON.stringify(args),\n` +
				`\t\t\t});\n` +
				`\t\t\treturn parseJson<${pascal}Result>(response);\n` +
				`\t\t},`
			);
		})
		.join("\n");

	const queriesTypeLines = queries
		.map((h) => {
			const pascal = pascalCase(h.name);
			return `\t${h.name}: HandlerInvoker<${pascal}Args, ${pascal}Result>;`;
		})
		.join("\n");

	const mutationsTypeLines = mutations
		.map((h) => {
			const pascal = pascalCase(h.name);
			return `\t${h.name}: HandlerInvoker<${pascal}Args, ${pascal}Result>;`;
		})
		.join("\n");

	return `/* eslint-disable */
/**
 * This file is auto-generated by appflare/handler-build.ts.
 * Do not edit directly.
 */

import fetch from "better-fetch";

import type {
	AnyValidator,
	InferQueryArgs,
	MutationDefinition,
	QueryArgsShape,
	QueryDefinition,
} from "./schema-types";

type AnyArgsShape = Record<string, AnyValidator>;

type AnyHandlerDefinition = QueryDefinition<AnyArgsShape, unknown> | MutationDefinition<AnyArgsShape, unknown>;

type HandlerArgs<THandler extends AnyHandlerDefinition> =
	THandler extends { args: infer TArgs extends QueryArgsShape }
		? InferQueryArgs<TArgs>
		: never;

type HandlerResult<THandler extends AnyHandlerDefinition> = THandler extends {
	handler: (...args: any[]) => Promise<infer TResult>;
}
	? TResult
	: never;

type HandlerInvoker<TArgs, TResult> = (args: TArgs, init?: RequestInit) => Promise<TResult>;

type RequestExecutor = (
	input: RequestInfo | URL,
	init?: RequestInit
) => Promise<Response>;

const defaultFetcher: RequestExecutor = (input, init) => fetch(input, init);

${typeBlocks.join("\n\n")}

export type QueriesClient = {
${queriesTypeLines || "\t// (none)"}
};

export type MutationsClient = {
${mutationsTypeLines || "\t// (none)"}
};

export type AppflareApiClient = {
	queries: QueriesClient;
	mutations: MutationsClient;
};

export type AppflareApiOptions = {
	baseUrl?: string;
	fetcher?: RequestExecutor;
};

export function createAppflareApi(options: AppflareApiOptions = {}): AppflareApiClient {
	const baseUrl = normalizeBaseUrl(options.baseUrl);
	const request = options.fetcher ?? defaultFetcher;
	const queries: QueriesClient = {
${queriesClientLines || "\t\t// (none)"}
	};
	const mutations: MutationsClient = {
${mutationsClientLines || "\t\t// (none)"}
	};
	return { queries, mutations };
}

function normalizeBaseUrl(baseUrl?: string): string {
	if (!baseUrl) {
		return "";
	}
	return baseUrl.endsWith("/") ? baseUrl.slice(0, -1) : baseUrl;
}

function buildUrl(baseUrl: string, path: string): string {
	if (!baseUrl) {
		return path;
	}
	const normalizedPath = path.startsWith("/") ? path : "/" + path;
	return baseUrl + normalizedPath;
}

function buildQueryUrl(
	baseUrl: string,
	path: string,
	params: Record<string, unknown> | undefined
): string {
	const url = buildUrl(baseUrl, path);
	const query = serializeQueryParams(params);
	return query ? url + "?" + query : url;
}

function serializeQueryParams(
	params: Record<string, unknown> | undefined
): string {
	if (!params) {
		return "";
	}
	const searchParams = new URLSearchParams();
	for (const [key, value] of Object.entries(params)) {
		if (value === undefined || value === null) {
			continue;
		}
		if (Array.isArray(value)) {
			for (const entry of value) {
				searchParams.append(key, serializeQueryValue(entry));
			}
			continue;
		}
		searchParams.append(key, serializeQueryValue(value));
	}
	return searchParams.toString();
}

function serializeQueryValue(value: unknown): string {
	if (value instanceof Date) {
		return value.toISOString();
	}
	if (typeof value === "object") {
		return JSON.stringify(value);
	}
	return String(value);
}

function ensureJsonHeaders(headers?: HeadersInit): HeadersInit {
	if (!headers) {
		return { "content-type": "application/json" };
	}
	if (typeof Headers !== "undefined" && headers instanceof Headers) {
		const next = new Headers(headers);
		if (!next.has("content-type")) {
			next.set("content-type", "application/json");
		}
		return next;
	}
	if (Array.isArray(headers)) {
		const entries = headers.slice();
		const hasContentType = entries.some(
			([key]) => key.toLowerCase() === "content-type"
		);
		if (!hasContentType) {
			entries.push(["content-type", "application/json"]);
		}
		return entries;
	}
	if (typeof headers === "object") {
		const record = { ...(headers as Record<string, string>) };
		if (!hasHeader(record, "content-type")) {
			record["content-type"] = "application/json";
		}
		return record;
	}
	return { "content-type": "application/json" };
}

function hasHeader(record: Record<string, string>, name: string): boolean {
	const needle = name.toLowerCase();
	return Object.keys(record).some((key) => key.toLowerCase() === needle);
}

async function parseJson<TResult>(response: Response): Promise<TResult> {
	if (!response.ok) {
		throw new Error("Request failed with status " + response.status);
	}
	return (await response.json()) as TResult;
}
`;
}

export function generateHonoServer(params: {
	handlers: DiscoveredHandler[];
	outDirAbs: string;
}): string {
	const queries = params.handlers.filter((h) => h.kind === "query");
	const mutations = params.handlers.filter((h) => h.kind === "mutation");

	const grouped = groupBy(params.handlers, (h) => h.sourceFileAbs);
	const importLines: string[] = [];
	for (const [fileAbs, list] of Array.from(grouped.entries())) {
		const specifiers = list.map((h) => h.name).sort();
		const importPath = toImportPathFromGeneratedServer(
			params.outDirAbs,
			fileAbs
		);
		importLines.push(
			`import { ${specifiers.join(", ")} } from ${JSON.stringify(importPath)};`
		);
	}

	const routeLines: string[] = [];
	for (const q of queries) {
		routeLines.push(
			`app.get(\n` +
				`\t${JSON.stringify(`/queries/${q.name}`)},\n` +
				`\tsValidator("query", z.object(${q.name}.args as any)),\n` +
				`\tasync (c) => {\n` +
				`\t\tconst query = c.req.valid("query");\n` +
				`\t\tconst result = await ${q.name}.handler(appflareContext, query as any);\n` +
				`\t\treturn c.json(result, 200);\n` +
				`\t}\n` +
				`);`
		);
	}
	for (const m of mutations) {
		routeLines.push(
			`app.post(\n` +
				`\t${JSON.stringify(`/mutations/${m.name}`)},\n` +
				`\tsValidator("json", z.object(${m.name}.args as any)),\n` +
				`\tasync (c) => {\n` +
				`\t\tconst body = c.req.valid("json");\n` +
				`\t\tconst result = await ${m.name}.handler(appflareContext, body as any);\n` +
				`\t\treturn c.json(result, 200);\n` +
				`\t}\n` +
				`);`
		);
	}

	return `/* eslint-disable */
/**
 * This file is auto-generated by appflare/handler-build.ts.
 * Do not edit directly.
 */

import { Hono } from "hono";
import { sValidator } from "@hono/standard-validator";
import { z } from "zod";
import { cors } from "hono/cors";

${importLines.join("\n")}

const appflareContext = {
	db: {
		query: (tableName: string) => {
			const cursor = {
				where: (_filter: any) => cursor,
				sort: (_sort: any) => cursor,
				select: (_keys: any) => cursor,
				populate: (_keys: any) => cursor,
				limit: (_limit: number) => cursor,
				offset: (_offset: number) => cursor,
				find: async () => {
					return [{ id: "1", table: tableName, text: "Hello World" }];
				},
				findOne: async () => {
					return { id: "1", table: tableName, text: "Hello World" };
				},
			};
			return cursor;
		},
		insert: async (_table: string, _value: any) => "1",
		update: async (_table: string, _id: any, _partial: any) => {},
		patch: async (_table: string, _id: any, _partial: any) => {},
		delete: async (_table: string, _id: any) => {},
	},
} as any;

const app = new Hono();
app.use(
	cors({
		origin: "*",
	})
);

${routeLines.join("\n\n")}

export default app;
`;
}
