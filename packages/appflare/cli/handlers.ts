import { promises as fs } from "node:fs";
import path from "node:path";
import {
	DiscoveredHandler,
	HandlerKind,
	isValidIdentifier,
	pascalCase,
	walkTsFiles,
	groupBy,
	toImportPathFromGeneratedSrc,
	toImportPathFromGeneratedServer,
} from "./utils";

export async function discoverHandlers(params: {
	projectDirAbs: string;
	schemaPathAbs: string;
	outDirAbs: string;
	configPathAbs: string;
}): Promise<DiscoveredHandler[]> {
	const ignoreDirs = new Set([
		"node_modules",
		".git",
		"dist",
		"build",
		path.basename(params.outDirAbs),
	]);

	const files = await walkTsFiles(params.projectDirAbs, ignoreDirs);

	const handlers: DiscoveredHandler[] = [];
	for (const fileAbs of files) {
		if (path.resolve(fileAbs) === path.resolve(params.schemaPathAbs)) continue;
		if (path.resolve(fileAbs) === path.resolve(params.configPathAbs)) continue;

		const content = await fs.readFile(fileAbs, "utf8");
		const regex =
			/export\s+const\s+([A-Za-z_$][\w$]*)\s*=\s*(query|mutation)\s*\(/g;
		let match: RegExpExecArray | null;
		while ((match = regex.exec(content)) !== null) {
			handlers.push({
				fileName: path.basename(fileAbs, ".ts"),
				name: match[1],
				kind: match[2] as HandlerKind,
				sourceFileAbs: fileAbs,
			});
		}
	}

	// De-dupe: keep first occurrence
	const seen = new Set<string>();
	const unique = handlers.filter((h) => {
		const key = `${h.kind}:${h.fileName}:${h.name}`;
		if (seen.has(key)) return false;
		seen.add(key);
		return true;
	});

	unique.sort((a, b) => {
		if (a.kind !== b.kind) return a.kind.localeCompare(b.kind);
		if (a.fileName !== b.fileName) return a.fileName.localeCompare(b.fileName);
		return a.name.localeCompare(b.name);
	});

	return unique;
}

export async function generateDbHandlers(params: {
	outDirAbs: string;
	tableNames: string[];
}): Promise<void> {
	const handlersDir = path.join(params.outDirAbs, "src", "handlers");
	await fs.mkdir(handlersDir, { recursive: true });

	// Clean existing handler files to avoid stale tables lingering.
	const existing = await fs.readdir(handlersDir).catch(() => [] as string[]);
	await Promise.all(
		existing
			.filter((name) => name.endsWith(".ts"))
			.map((name) =>
				fs.unlink(path.join(handlersDir, name)).catch(() => void 0)
			)
	);

	const exportLines: string[] = [];
	for (const tableName of params.tableNames) {
		const pascal = pascalCase(tableName);
		const findFn = `find${pascal}`;
		const findOneFn = `findOne${pascal}`;
		const insertFn = `insert${pascal}`;
		const updateFn = `update${pascal}`;
		const deleteFn = `delete${pascal}`;
		const fileName = `${tableName}.ts`;
		const content = `/* eslint-disable */
/**
 * This file is auto-generated by appflare/db-build.ts.
 * Do not edit directly.
 */
import { z } from "zod";
import {
	mutation,
	query,
	type EditableDoc,
	type Id,
	type QuerySort,
	type QueryWhere,
} from "../schema-types";

export const ${findFn} = query({
	args: {
		where: z.custom<QueryWhere<${JSON.stringify(tableName)}>>().optional(),
		sort: z.custom<QuerySort<${JSON.stringify(tableName)}>>().optional(),
		limit: z.number().int().nonnegative().optional(),
		offset: z.number().int().nonnegative().optional(),
	},
	handler: async (ctx, args) => {
		let q = ctx.db.query(${JSON.stringify(tableName)} as any);
		if (args.where) q = q.where(args.where as any);
		if (args.sort) q = q.sort(args.sort as any);
		if (args.offset !== undefined) q = q.offset(args.offset);
		if (args.limit !== undefined) q = q.limit(args.limit);
		return q.find();
	},
});

export const ${findOneFn} = query({
	args: {
		where: z.custom<QueryWhere<${JSON.stringify(tableName)}>>().optional(),
		sort: z.custom<QuerySort<${JSON.stringify(tableName)}>>().optional(),
		offset: z.number().int().nonnegative().optional(),
	},
	handler: async (ctx, args) => {
		let q = ctx.db.query(${JSON.stringify(tableName)} as any);
		if (args.where) q = q.where(args.where as any);
		if (args.sort) q = q.sort(args.sort as any);
		if (args.offset !== undefined) q = q.offset(args.offset);
		return q.findOne();
	},
});

export const ${insertFn} = mutation({
	args: {
		value: z.custom<EditableDoc<${JSON.stringify(tableName)}>>(),
	},
	handler: async (ctx, args) => {
		return ctx.db.insert(${JSON.stringify(tableName)} as any, args.value as any);
	},
});

export const ${updateFn} = mutation({
	args: {
		id: z.custom<Id<${JSON.stringify(tableName)}>>().optional(),
		where: z.custom<QueryWhere<${JSON.stringify(tableName)}>>().optional(),
		partial: z.custom<Partial<EditableDoc<${JSON.stringify(tableName)}>>>(),
	},
	handler: async (ctx, args) => {
		const filter = (args.where ?? args.id) as any;
		if (!filter) {
			throw new Error("update requires either args.where or args.id");
		}
		if (typeof (ctx.db as any).update === "function") {
			await (ctx.db as any).update(
				${JSON.stringify(tableName)} as any,
				filter,
				args.partial as any
			);
			return;
		}
		await ctx.db.patch(
			${JSON.stringify(tableName)} as any,
			filter,
			args.partial as any
		);
	},
});

export const ${deleteFn} = mutation({
	args: {
		id: z.custom<Id<${JSON.stringify(tableName)}>>().optional(),
		where: z.custom<QueryWhere<${JSON.stringify(tableName)}>>().optional(),
	},
	handler: async (ctx, args) => {
		const filter = (args.where ?? args.id) as any;
		if (!filter) {
			throw new Error("delete requires either args.where or args.id");
		}
		await ctx.db.delete(${JSON.stringify(tableName)} as any, filter);
	},
});
`;
		await fs.writeFile(path.join(handlersDir, fileName), content);
		exportLines.push(
			`export { ${findFn}, ${findOneFn}, ${insertFn}, ${updateFn}, ${deleteFn} } from "./${tableName}";`
		);
	}

	const indexTs = `/* eslint-disable */
/**
 * This file is auto-generated by appflare/db-build.ts.
 * Do not edit directly.
 */
${exportLines.join("\n")}
`;
	await fs.writeFile(path.join(handlersDir, "index.ts"), indexTs);
}

export function generateApiClient(params: {
	handlers: DiscoveredHandler[];
	outDirAbs: string;
}): string {
	const queries = params.handlers.filter((h) => h.kind === "query");
	const mutations = params.handlers.filter((h) => h.kind === "mutation");

	const queriesByFile = groupBy(queries, (h) => h.fileName);
	const mutationsByFile = groupBy(mutations, (h) => h.fileName);

	const sortedEntries = <T>(map: Map<string, T[]>): Array<[string, T[]]> =>
		Array.from(map.entries()).sort(([a], [b]) => a.localeCompare(b));

	const renderObjectKey = (key: string): string =>
		isValidIdentifier(key) ? key : JSON.stringify(key);

	const handlerTypePrefix = (h: DiscoveredHandler): string =>
		pascalCase(`${h.fileName}-${h.name}`);

	const typeBlocks: string[] = [];
	for (const h of params.handlers) {
		const importPath = toImportPathFromGeneratedSrc(
			params.outDirAbs,
			h.sourceFileAbs
		);
		const pascal = handlerTypePrefix(h);
		typeBlocks.push(
			`type ${pascal}Definition = typeof import(${JSON.stringify(importPath)})[${JSON.stringify(h.name)}];\n` +
				`type ${pascal}Args = HandlerArgs<${pascal}Definition>;\n` +
				`type ${pascal}Result = HandlerResult<${pascal}Definition>;`
		);
	}

	const queriesTypeLines = sortedEntries(queriesByFile)
		.map(([fileName, list]) => {
			const fileKey = renderObjectKey(fileName);
			const inner = list
				.slice()
				.sort((a, b) => a.name.localeCompare(b.name))
				.map((h) => {
					const pascal = handlerTypePrefix(h);
					return `\t\t${h.name}: HandlerInvoker<${pascal}Args, ${pascal}Result>;`;
				})
				.join("\n");
			return `\t${fileKey}: {\n${inner || "\t\t// (none)"}\n\t};`;
		})
		.join("\n");

	const mutationsTypeLines = sortedEntries(mutationsByFile)
		.map(([fileName, list]) => {
			const fileKey = renderObjectKey(fileName);
			const inner = list
				.slice()
				.sort((a, b) => a.name.localeCompare(b.name))
				.map((h) => {
					const pascal = handlerTypePrefix(h);
					return `\t\t${h.name}: HandlerInvoker<${pascal}Args, ${pascal}Result>;`;
				})
				.join("\n");
			return `\t${fileKey}: {\n${inner || "\t\t// (none)"}\n\t};`;
		})
		.join("\n");

	const queriesClientLines = sortedEntries(queriesByFile)
		.map(([fileName, list]) => {
			const fileKey = renderObjectKey(fileName);
			const inner = list
				.slice()
				.sort((a, b) => a.name.localeCompare(b.name))
				.map((h) => {
					const pascal = handlerTypePrefix(h);
					const route = `/queries/${fileName}/${h.name}`;
					return (
						`\t\t${h.name}: async (args: ${pascal}Args, init) => {\n` +
						`\t\t\tconst url = buildQueryUrl(baseUrl, ${JSON.stringify(route)}, args);\n` +
						`\t\t\tconst response = await request(url, {\n` +
						`\t\t\t\t...(init ?? {}),\n` +
						`\t\t\t\tmethod: "GET",\n` +
						`\t\t\t});\n` +
						`\t\t\treturn parseJson<${pascal}Result>(response);\n` +
						`\t\t},`
					);
				})
				.join("\n");
			return `\t${fileKey}: {\n${inner || "\t\t// (none)"}\n\t},`;
		})
		.join("\n");

	const mutationsClientLines = sortedEntries(mutationsByFile)
		.map(([fileName, list]) => {
			const fileKey = renderObjectKey(fileName);
			const inner = list
				.slice()
				.sort((a, b) => a.name.localeCompare(b.name))
				.map((h) => {
					const pascal = handlerTypePrefix(h);
					const route = `/mutations/${fileName}/${h.name}`;
					return (
						`\t\t${h.name}: async (args: ${pascal}Args, init) => {\n` +
						`\t\t\tconst url = buildUrl(baseUrl, ${JSON.stringify(route)});\n` +
						`\t\t\tconst response = await request(url, {\n` +
						`\t\t\t\t...(init ?? {}),\n` +
						`\t\t\t\tmethod: "POST",\n` +
						`\t\t\t\theaders: ensureJsonHeaders(init?.headers),\n` +
						`\t\t\t\tbody: JSON.stringify(args),\n` +
						`\t\t\t});\n` +
						`\t\t\treturn parseJson<${pascal}Result>(response);\n` +
						`\t\t},`
					);
				})
				.join("\n");
			return `\t${fileKey}: {\n${inner || "\t\t// (none)"}\n\t},`;
		})
		.join("\n");

	const queriesTypeDef =
		queriesByFile.size === 0 ? "{}" : `{\n${queriesTypeLines}\n}`;
	const mutationsTypeDef =
		mutationsByFile.size === 0 ? "{}" : `{\n${mutationsTypeLines}\n}`;

	const queriesInit =
		queriesByFile.size === 0 ? "{}" : `{\n${queriesClientLines}\n\t}`;
	const mutationsInit =
		mutationsByFile.size === 0 ? "{}" : `{\n${mutationsClientLines}\n\t}`;

	return `/* eslint-disable */
/**
 * This file is auto-generated by appflare/handler-build.ts.
 * Do not edit directly.
 */

import fetch from "better-fetch";

import type {
	AnyValidator,
	InferQueryArgs,
	MutationDefinition,
	QueryArgsShape,
	QueryDefinition,
} from "./schema-types";

type AnyArgsShape = Record<string, AnyValidator>;

type AnyHandlerDefinition = QueryDefinition<AnyArgsShape, unknown> | MutationDefinition<AnyArgsShape, unknown>;

type HandlerArgs<THandler extends AnyHandlerDefinition> =
	THandler extends { args: infer TArgs extends QueryArgsShape }
		? InferQueryArgs<TArgs>
		: never;

type HandlerResult<THandler extends AnyHandlerDefinition> = THandler extends {
	handler: (...args: any[]) => Promise<infer TResult>;
}
	? TResult
	: never;

type HandlerInvoker<TArgs, TResult> = (args: TArgs, init?: RequestInit) => Promise<TResult>;

type RequestExecutor = (
	input: RequestInfo | URL,
	init?: RequestInit
) => Promise<Response>;

const defaultFetcher: RequestExecutor = (input, init) => fetch(input, init);

${typeBlocks.join("\n\n")}

export type QueriesClient = ${queriesTypeDef};

export type MutationsClient = ${mutationsTypeDef};

export type AppflareApiClient = {
	queries: QueriesClient;
	mutations: MutationsClient;
};

export type AppflareApiOptions = {
	baseUrl?: string;
	fetcher?: RequestExecutor;
};

export function createAppflareApi(options: AppflareApiOptions = {}): AppflareApiClient {
	const baseUrl = normalizeBaseUrl(options.baseUrl);
	const request = options.fetcher ?? defaultFetcher;
	const queries: QueriesClient = ${queriesInit};
	const mutations: MutationsClient = ${mutationsInit};
	return { queries, mutations };
}

function normalizeBaseUrl(baseUrl?: string): string {
	if (!baseUrl) {
		return "";
	}
	return baseUrl.endsWith("/") ? baseUrl.slice(0, -1) : baseUrl;
}

function buildUrl(baseUrl: string, path: string): string {
	if (!baseUrl) {
		return path;
	}
	const normalizedPath = path.startsWith("/") ? path : "/" + path;
	return baseUrl + normalizedPath;
}

function buildQueryUrl(
	baseUrl: string,
	path: string,
	params: Record<string, unknown> | undefined
): string {
	const url = buildUrl(baseUrl, path);
	const query = serializeQueryParams(params);
	return query ? url + "?" + query : url;
}

function serializeQueryParams(
	params: Record<string, unknown> | undefined
): string {
	if (!params) {
		return "";
	}
	const searchParams = new URLSearchParams();
	for (const [key, value] of Object.entries(params)) {
		if (value === undefined || value === null) {
			continue;
		}
		if (Array.isArray(value)) {
			for (const entry of value) {
				searchParams.append(key, serializeQueryValue(entry));
			}
			continue;
		}
		searchParams.append(key, serializeQueryValue(value));
	}
	return searchParams.toString();
}

function serializeQueryValue(value: unknown): string {
	if (value instanceof Date) {
		return value.toISOString();
	}
	if (typeof value === "object") {
		return JSON.stringify(value);
	}
	return String(value);
}

function ensureJsonHeaders(headers?: HeadersInit): HeadersInit {
	if (!headers) {
		return { "content-type": "application/json" };
	}
	if (typeof Headers !== "undefined" && headers instanceof Headers) {
		const next = new Headers(headers);
		if (!next.has("content-type")) {
			next.set("content-type", "application/json");
		}
		return next;
	}
	if (Array.isArray(headers)) {
		const entries = headers.slice();
		const hasContentType = entries.some(
			([key]) => key.toLowerCase() === "content-type"
		);
		if (!hasContentType) {
			entries.push(["content-type", "application/json"]);
		}
		return entries;
	}
	if (typeof headers === "object") {
		const record = { ...(headers as Record<string, string>) };
		if (!hasHeader(record, "content-type")) {
			record["content-type"] = "application/json";
		}
		return record;
	}
	return { "content-type": "application/json" };
}

function hasHeader(record: Record<string, string>, name: string): boolean {
	const needle = name.toLowerCase();
	return Object.keys(record).some((key) => key.toLowerCase() === needle);
}

async function parseJson<TResult>(response: Response): Promise<TResult> {
	if (!response.ok) {
		throw new Error("Request failed with status " + response.status);
	}
	return (await response.json()) as TResult;
}
`;
}

export function generateHonoServer(params: {
	handlers: DiscoveredHandler[];
	outDirAbs: string;
	schemaPathAbs: string;
}): string {
	const queries = params.handlers.filter((h) => h.kind === "query");
	const mutations = params.handlers.filter((h) => h.kind === "mutation");
	const schemaImportPath = toImportPathFromGeneratedServer(
		params.outDirAbs,
		params.schemaPathAbs
	);

	const localNameFor = (h: DiscoveredHandler): string =>
		`__appflare_${pascalCase(h.fileName)}_${h.name}`;

	const grouped = groupBy(params.handlers, (h) => h.sourceFileAbs);
	const importLines: string[] = [];
	for (const [fileAbs, list] of Array.from(grouped.entries())) {
		const specifiers = list
			.slice()
			.sort((a, b) => a.name.localeCompare(b.name))
			.map((h) => `${h.name} as ${localNameFor(h)}`);
		const importPath = toImportPathFromGeneratedServer(
			params.outDirAbs,
			fileAbs
		);
		importLines.push(
			`import { ${specifiers.join(", ")} } from ${JSON.stringify(importPath)};`
		);
	}

	const routeLines: string[] = [];
	for (const q of queries) {
		const local = localNameFor(q);
		routeLines.push(
			`app.get(\n` +
				`\t${JSON.stringify(`/queries/${q.fileName}/${q.name}`)},\n` +
				`\tsValidator("query", z.object(${local}.args as any)),\n` +
				`\tasync (c) => {\n` +
				`\t\tconst query = c.req.valid("query");\n` +
				`\t\tconst ctx = await createContext(c);\n` +
				`\t\tconst result = await ${local}.handler(ctx as any, query as any);\n` +
				`\t\treturn c.json(result, 200);\n` +
				`\t}\n` +
				`);`
		);
	}
	for (const m of mutations) {
		const local = localNameFor(m);
		routeLines.push(
			`app.post(\n` +
				`\t${JSON.stringify(`/mutations/${m.fileName}/${m.name}`)},\n` +
				`\tsValidator("json", z.object(${local}.args as any)),\n` +
				`\tasync (c) => {\n` +
				`\t\tconst body = c.req.valid("json");\n` +
				`\t\tconst ctx = await createContext(c);\n` +
				`\t\tconst result = await ${local}.handler(ctx as any, body as any);\n` +
				`\t\treturn c.json(result, 200);\n` +
				`\t}\n` +
				`);`
		);
	}

	return `/* eslint-disable */
/**
 * This file is auto-generated by appflare/handler-build.ts.
 * Do not edit directly.
 */

import { Hono } from "hono";
import type { Context as HonoContext } from "hono";
import { sValidator } from "@hono/standard-validator";
import { z } from "zod";
import { cors } from "hono/cors";
import schema from ${JSON.stringify(schemaImportPath)};
import {
	createMongoDbContext,
	type MongoDbContext,
} from "appflare/server/db";

import type { TableDocMap, TableNames } from "../src/schema-types";

${importLines.join("\n")}

export type AppflareDbContext = MongoDbContext<TableNames, TableDocMap>;

export type AppflareServerContext = { db: AppflareDbContext };

export type AppflareHonoServerOptions = {
	/** Provide a static Mongo Db instance. If omitted, set getDb instead. */
	db?: import("mongodb").Db;
	/** Provide a per-request Mongo Db instance (e.g. from Cloudflare env bindings). */
	getDb?: (c: HonoContext) => import("mongodb").Db | Promise<import("mongodb").Db>;
	/** Optionally extend the context beyond the db wrapper. */
	createContext?: (
		c: HonoContext,
		db: AppflareDbContext
	) => AppflareServerContext | Promise<AppflareServerContext>;
	collectionName?: (table: TableNames) => string;
	corsOrigin?: string | string[];
};

export function createAppflareHonoServer(options: AppflareHonoServerOptions): Hono {
	const fixedDb =
		options.db &&
		createMongoDbContext<TableNames, TableDocMap>({
			db: options.db,
			schema,
			collectionName: options.collectionName,
		});

	if (!fixedDb && !options.getDb) {
		throw new Error(
			"AppflareHonoServer requires either options.db or options.getDb to initialize the database context."
		);
	}

	const resolveDb = async (c: HonoContext): Promise<AppflareDbContext> => {
		if (fixedDb) return fixedDb;
		const db = await options.getDb!(c);
		return createMongoDbContext<TableNames, TableDocMap>({
			db,
			schema,
			collectionName: options.collectionName,
		});
	};

	const createContext =
		options.createContext ?? ((_c, db) => ({ db } as AppflareServerContext));
	const app = new Hono();
	app.use(
		cors({
			origin: options.corsOrigin ?? "*",
		})
	);

	${routeLines
		.map((line) =>
			line.replace(
				"const ctx = await createContext(c);",
				"const db = await resolveDb(c);\n\t\tconst ctx = await createContext(c, db);"
			)
		)
		.join("\n\n\t")}

	return app;
}

const app = createAppflareHonoServer({
	getDb: () => {
		throw new Error(
			"AppflareHonoServer default export requires options.db or options.getDb. Provide one when creating the server."
		);
	},
});

export default app;
`;
}
