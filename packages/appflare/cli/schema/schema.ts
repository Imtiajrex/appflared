import { pathToFileURL } from "node:url";
import { staticTypeDefinitions } from "./schema-static-types";
import { pascalCase } from "../utils/utils";
import { getZodObjectShape, renderField } from "../utils/zod-utils";

function generateDocParts(
	tableNames: string[],
	schema: any
): {
	docInterfaces: string[];
	docMapEntries: string[];
	tableIndexEntries: string[];
} {
	const docInterfaces: string[] = [];
	const docMapEntries: string[] = [];
	const tableIndexEntries: string[] = [];

	for (const tableName of tableNames) {
		const validator = (schema as any)[tableName];
		const shape = getZodObjectShape(validator);
		const interfaceName = pascalCase(`${tableName}Doc`);

		const fields = Object.entries(shape);
		const lines: string[] = [];
		lines.push(`export interface ${interfaceName} {`);
		lines.push(`\t_id: Id<${JSON.stringify(tableName)}>;`);
		lines.push(`\t_creationTime: number;`);
		for (const [fieldName, fieldSchema] of fields) {
			const rendered = renderField(fieldName, fieldSchema);
			lines.push(`\t${rendered}`);
		}
		lines.push(`}`);

		docInterfaces.push(lines.join("\n"));
		docMapEntries.push(`\t${tableName}: ${interfaceName};`);
		tableIndexEntries.push(`\t${tableName}: [],`);
	}

	return { docInterfaces, docMapEntries, tableIndexEntries };
}

export async function getSchemaTableNames(
	schemaPathAbs: string
): Promise<string[]> {
	const mod = await import(pathToFileURL(schemaPathAbs).href);
	const schema = mod?.default ?? mod;
	if (!schema || typeof schema !== "object") {
		throw new Error(
			`Invalid schema export in ${schemaPathAbs} (expected default export object)`
		);
	}
	return Object.keys(schema).sort();
}

export async function generateSchemaTypes(params: {
	schemaPathAbs: string;
}): Promise<string> {
	const mod = await import(pathToFileURL(params.schemaPathAbs).href);
	const schema = mod?.default ?? mod;
	if (!schema || typeof schema !== "object") {
		throw new Error(
			`Invalid schema export in ${params.schemaPathAbs} (expected default export object)`
		);
	}

	const tableNames = Object.keys(schema).sort();
	if (tableNames.length === 0) {
		throw new Error(`Schema has no tables in ${params.schemaPathAbs}`);
	}

	const { docInterfaces, docMapEntries, tableIndexEntries } = generateDocParts(
		tableNames,
		schema
	);

	return `/* eslint-disable */
/**
 * This file is auto-generated by appflare/db-build.ts.
 * Do not edit directly.
 */
type SchemaValidator<TValue> = {
	parse: (value: unknown) => TValue;
};

export type AnyValidator = SchemaValidator<unknown>;

export type TableNames = ${tableNames.map((t) => JSON.stringify(t)).join(" | ")};

export type Id<TableName extends TableNames> = string & { __table?: TableName };

${docInterfaces.join("\n\n")}

export interface TableDocMap {
${docMapEntries.join("\n")}
}

export type Doc<TableName extends TableNames> = TableDocMap[TableName];

${staticTypeDefinitions}

export const tableIndexes = {
${tableIndexEntries.join("\n")}
} as const;
`;
}
