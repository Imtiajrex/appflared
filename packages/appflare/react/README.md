## React hooks (`react/`)

Entry point re-exports hooks ([packages/appflare/react/index.ts](packages/appflare/react/index.ts)). Hooks expect handlers generated by the Appflare client (each handler has `.path`, `.schema`, and `.websocket` metadata).

### Shared realtime utilities

- Located in [packages/appflare/react/shared/queryShared.ts](packages/appflare/react/shared/queryShared.ts).
- `useRealtimeSubscription` wires a handlerâ€™s `websocket` helper into React Query caches; accepts `realtime` options (`enabled`, `baseUrl`, `where`, `orderBy`, `onMessage`, `onData`, etc.).
- Helpers: `buildQueryKey(queryKey, handler, argsKey)` and `stableSerialize(value)` for deterministic keys.

### `useQuery`

- File: [packages/appflare/react/hooks/useQuery.ts](packages/appflare/react/hooks/useQuery.ts).
- Wraps `@tanstack/react-query` `useQuery` and injects realtime updates when the handler exposes `websocket`.
- Signature: `useQuery({ handler, args?, queryKey?, queryOptions?, realtime? })` or `useQuery(handler, { ... })`.
- Returns the React Query result plus `{ websocket }` (the live socket or `null`).
- Realtime: if enabled, incoming `data` arrays replace the cached result via `setQueryData`.

### `usePaginatedQuery`

- File: [packages/appflare/react/hooks/usePaginatedQuery.ts](packages/appflare/react/hooks/usePaginatedQuery.ts).
- Wraps `useInfiniteQuery` for cursor pagination.
- Options: `pageParamKey` (default `"cursor"`), `initialPageParam`, `getNextPageParam`, `getPreviousPageParam`, plus `realtime` controls.
- On realtime `data`, replaces the first page in the cache to keep pagination metadata intact.

### `useMutation`

- File: [packages/appflare/react/hooks/useMutation.ts](packages/appflare/react/hooks/useMutation.ts).
- Thin wrapper over `useMutation`; builds a `mutationKey` from `handler.path` when provided.
- Signature: `useMutation({ handler, mutationKey?, mutationOptions? })` or `useMutation(handler, { ... })`.

### React usage example

```tsx
import { createAppflareApi } from "../_generated/src/api";
import { useQuery, useMutation } from "appflare/react";

const api = createAppflareApi({ baseUrl: "/api" });

export function Users() {
	const users = useQuery(api.queries.users.list, {
		realtime: { baseUrl: "wss://my-app/ws" },
	});

	const createUser = useMutation(api.mutations.users.create, {
		mutationOptions: { onSuccess: () => users.refetch() },
	});

	return (
		<div>
			<button onClick={() => createUser.mutate({ name: "Ada" })}>
				Add user
			</button>
			{users.data?.map((u) => (
				<div key={u._id}>{u.name}</div>
			))}
		</div>
	);
}
```

## Integration tips

- Handlers come from the generated client; ensure you pass the same `baseUrl`/`realtime.baseUrl` you configured in the server/Durable Object.
- Realtime is opt-in per hook via `realtime: true` or options; if the handler lacks `websocket`, no socket is opened.
- Use `queryKey`/`mutationKey` overrides when multiple instances of the same handler need isolated caches.
- `v.id("table")` pairs with `describe("ref:<table>")`; keep table names consistent with your schema for proper typing in generated code.
