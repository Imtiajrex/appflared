import { spawn } from "node:child_process";
import { watch, type FSWatcher } from "node:fs";
import { access, mkdir, rm, writeFile } from "node:fs/promises";
import { dirname, join, normalize, relative, resolve, sep } from "node:path";
import { fileURLToPath, pathToFileURL } from "node:url";

import type { AnyValidator, SchemaDefinition, ValidatorMeta } from "../db";
import { importConfigModule } from "./utils";

export { resolveConfigPathFromArgs } from "./utils";

export type TableFieldInfo = {
	name: string;
	meta: ValidatorMeta;
};

export type TableInfo = {
	name: string;
	pascalName: string;
	docInterfaceName: string;
	fields: TableFieldInfo[];
	indexes: Array<{ name: string; fields: string[] }>;
};

export type AppflareConfig = {
	dir: string;
	outDir: string;
};

export type BuildPaths = {
	configPath: string;
	configDir: string;
	projectDir: string;
	schemaPath: string;
	generatedRoot: string;
	srcDir: string;
	handlersDir: string;
	distDir: string;
	tsconfigPath: string;
};

const AUTO_GENERATED_BANNER = `/* eslint-disable */
/**
 * This file is auto-generated by appflare/db-build.ts.
 * Do not edit directly.
 */
`;

const THIS_FILE = fileURLToPath(import.meta.url);
const BUILD_SCRIPTS_DIR = resolve(THIS_FILE, "..");
const PACKAGE_DIR = resolve(BUILD_SCRIPTS_DIR, "..");
const REPO_ROOT = resolve(PACKAGE_DIR, "..");

export async function runDbBuild(configPath: string): Promise<BuildPaths> {
	const config = await loadConfig(configPath);
	const paths = resolveBuildPaths(configPath, config);
	await performBuild(paths);
	return paths;
}

export async function watchDbBuild(configPath: string): Promise<void> {
	const initialPaths = await runDbBuild(configPath);
	await watchForChanges(configPath, initialPaths);
}

async function loadConfig(configFile: string): Promise<AppflareConfig> {
	const config = await importConfigModule<AppflareConfig>(configFile, {
		displayPath: relative(REPO_ROOT, configFile),
	});
	const dir = typeof config.dir === "string" ? config.dir : ".";
	const outDir =
		typeof config.outDir === "string" ? config.outDir : "./_generated";
	return { dir, outDir };
}

function resolveBuildPaths(
	configPath: string,
	config: AppflareConfig
): BuildPaths {
	const configDir = dirname(configPath);
	const projectDir = resolve(configDir, config.dir);
	const schemaPath = join(projectDir, "schema.ts");
	const generatedRoot = resolve(configDir, config.outDir);
	const srcDir = join(generatedRoot, "src");
	const handlersDir = join(srcDir, "handlers");
	const distDir = join(generatedRoot, "dist");
	const tsconfigPath = join(projectDir, "tsconfig.generated.json");
	return {
		configPath,
		configDir,
		projectDir,
		schemaPath,
		generatedRoot,
		srcDir,
		handlersDir,
		distDir,
		tsconfigPath,
	};
}

async function performBuild(paths: BuildPaths): Promise<void> {
	const schema = await loadSchema(paths.schemaPath);
	const tables = extractTables(schema);
	if (tables.length === 0) {
		throw new Error(
			`No tables were found in ${relative(REPO_ROOT, paths.schemaPath)}`
		);
	}
	await prepareOutputDirs(paths);
	await writeSchemaTypesFile(paths, tables);
	await Promise.all(tables.map((table) => writeHandlerFile(paths, table)));
	await writeHandlerIndex(paths, tables);
	await ensureGeneratedTsconfig(paths);
	await runTsc(paths.tsconfigPath, paths.projectDir);
	console.log(
		`[appflare db build] Generated ${tables.length} table handler${tables.length === 1 ? "" : "s"} under ${relative(
			REPO_ROOT,
			paths.generatedRoot
		)}`
	);
}

async function loadSchema(
	schemaFile: string
): Promise<SchemaDefinition<Record<string, unknown>>> {
	const moduleUrl = pathToFileURL(schemaFile).href;
	const imported = await import(moduleUrl);
	const schema = imported.default;
	if (!schema || typeof schema !== "object" || !("tableNames" in schema)) {
		throw new Error(
			`Schema at ${relative(REPO_ROOT, schemaFile)} does not export a default schema definition.`
		);
	}
	return schema as SchemaDefinition<Record<string, unknown>>;
}

function extractTables(
	schema: SchemaDefinition<Record<string, unknown>>
): TableInfo[] {
	return schema.tableNames.map((tableName) => {
		const tableDef = schema.getTable(tableName);
		const fields = Object.entries(tableDef.fields ?? {}) as Array<
			[string, AnyValidator]
		>;
		return {
			name: tableName,
			pascalName: pascalCase(tableName),
			docInterfaceName: `${pascalCase(tableName)}Doc`,
			fields: fields.map(([fieldName, validator]) => ({
				name: fieldName,
				meta: validator.meta,
			})),
			indexes: tableDef.indexes ?? [],
		};
	});
}

async function prepareOutputDirs(paths: BuildPaths): Promise<void> {
	await rm(paths.srcDir, { recursive: true, force: true });
	await rm(paths.distDir, { recursive: true, force: true });
	await mkdir(paths.handlersDir, { recursive: true });
}

async function writeSchemaTypesFile(
	paths: BuildPaths,
	tables: TableInfo[]
): Promise<void> {
	const target = join(paths.srcDir, "schema-types.ts");
	await mkdir(paths.srcDir, { recursive: true });
	await writeFile(target, renderSchemaTypes(tables), "utf8");
}

async function writeHandlerFile(
	paths: BuildPaths,
	table: TableInfo
): Promise<void> {
	const target = join(paths.handlersDir, `${table.name}.ts`);
	await writeFile(target, renderHandlerSource(table), "utf8");
}

async function writeHandlerIndex(
	paths: BuildPaths,
	tables: TableInfo[]
): Promise<void> {
	const target = join(paths.handlersDir, "index.ts");
	const exports = tables
		.map((table) => `export * from './${table.name}';`)
		.join("\n");
	await writeFile(target, `${AUTO_GENERATED_BANNER}${exports}\n`, "utf8");
}

async function ensureGeneratedTsconfig(paths: BuildPaths): Promise<void> {
	const tsconfigDir = dirname(paths.tsconfigPath);
	const outDir = formatRelativePath(relative(tsconfigDir, paths.distDir));
	const rootDir = formatRelativePath(relative(tsconfigDir, paths.srcDir));
	const includeGlob = formatRelativePath(
		relative(tsconfigDir, join(paths.srcDir, "**/*"))
	);
	const extendsPath = await resolveExtendsPath(paths, tsconfigDir);

	const config: {
		extends?: string;
		compilerOptions: Record<string, unknown>;
		include: string[];
	} = {
		compilerOptions: {
			noEmit: false,
			declaration: true,
			emitDeclarationOnly: false,
			outDir,
			rootDir,
			sourceMap: false,
			declarationMap: false,
			skipLibCheck: true,
			types: [],
		},
		include: [includeGlob],
	};

	if (extendsPath) {
		config.extends = extendsPath;
	}

	const json = `${JSON.stringify(config, null, 2)}\n`;
	await writeFile(paths.tsconfigPath, json, "utf8");
}

async function runTsc(tsconfig: string, cwd: string): Promise<void> {
	await runCommand("npx", ["tsc", "-p", tsconfig], cwd);
}

function runCommand(
	command: string,
	args: string[],
	cwd: string
): Promise<void> {
	return new Promise((resolvePromise, rejectPromise) => {
		const child = spawn(command, args, {
			cwd,
			stdio: "inherit",
			shell: false,
		});
		child.on("exit", (code) => {
			if (code === 0) {
				resolvePromise();
			} else {
				rejectPromise(
					new Error(`${command} ${args.join(" ")} exited with code ${code}`)
				);
			}
		});
		child.on("error", (error) => rejectPromise(error));
	});
}

function formatRelativePath(value: string): string {
	if (!value) {
		return ".";
	}
	return value.startsWith(".") ? value : `./${value}`;
}

async function resolveExtendsPath(
	paths: BuildPaths,
	tsconfigDir: string
): Promise<string | undefined> {
	const localTsconfig = join(paths.projectDir, "tsconfig.json");
	if (await pathExists(localTsconfig)) {
		return formatRelativePath(relative(tsconfigDir, localTsconfig));
	}
	return undefined;
}

async function pathExists(target: string): Promise<boolean> {
	try {
		await access(target);
		return true;
	} catch {
		return false;
	}
}

function renderSchemaTypes(tables: TableInfo[]): string {
	const tableNamesUnion = tables.map((table) => `'${table.name}'`).join(" | ");
	const docInterfaces = tables
		.map((table) => renderDocInterface(table))
		.join("\n\n");
	const tableMapLines = tables
		.map((table) => `\t'${table.name}': ${table.docInterfaceName};`)
		.join("\n");
	const indexesLiteral = renderIndexesLiteral(tables);
	return `${AUTO_GENERATED_BANNER}type SchemaValidator<TValue> = {\n\tparse: (value: unknown) => TValue;\n};\n\nexport type AnyValidator = SchemaValidator<unknown>;\n\nexport type TableNames = ${tableNamesUnion};\n\nexport type Id<TableName extends string> = string & { __table?: TableName };\n\n${docInterfaces}\n\nexport interface TableDocMap {\n${tableMapLines}\n}\n\nexport type Doc<TableName extends TableNames> = TableDocMap[TableName];\n\nexport interface DatabaseQuery<TableName extends TableNames> {\n\tcollect(): Promise<Array<TableDocMap[TableName]>>;\n}\n\nexport interface DatabaseReader {\n\tquery<TableName extends TableNames>(table: TableName): DatabaseQuery<TableName>;\n}\n\nexport interface QueryContext {\n\tdb: DatabaseReader;\n}\n\nexport type QueryArgsShape = Record<string, AnyValidator>;\n\ntype InferValidator<TValidator> = TValidator extends SchemaValidator<infer TValue> ? TValue : never;\n\nexport type InferQueryArgs<TArgs extends QueryArgsShape> = {\n\t[Key in keyof TArgs]: InferValidator<TArgs[Key]>;\n};\n\nexport interface QueryDefinition<TArgs extends QueryArgsShape, TResult> {\n\targs: TArgs;\n\thandler: (ctx: QueryContext, args: InferQueryArgs<TArgs>) => Promise<TResult>;\n}\n\nexport const query = <TArgs extends QueryArgsShape, TResult>(definition: QueryDefinition<TArgs, TResult>): QueryDefinition<TArgs, TResult> => definition;\n\nexport type EditableDoc<TableName extends TableNames> = Omit<TableDocMap[TableName], '_id' | '_creationTime'>;\n\nexport interface DatabaseWriter extends DatabaseReader {\n\tinsert<TableName extends TableNames>(table: TableName, value: EditableDoc<TableName>): Promise<Id<TableName>>;\n\tpatch<TableName extends TableNames>(table: TableName, id: Id<TableName>, partial: Partial<EditableDoc<TableName>>): Promise<void>;\n\tdelete<TableName extends TableNames>(table: TableName, id: Id<TableName>): Promise<void>;\n}\n\nexport interface MutationContext {\n\tdb: DatabaseWriter;\n}\n\nexport interface MutationDefinition<TArgs extends QueryArgsShape, TResult> {\n\targs: TArgs;\n\thandler: (ctx: MutationContext, args: InferQueryArgs<TArgs>) => Promise<TResult>;\n}\n\nexport const mutation = <TArgs extends QueryArgsShape, TResult>(definition: MutationDefinition<TArgs, TResult>): MutationDefinition<TArgs, TResult> => definition;\n\n${indexesLiteral}`;
}

function renderDocInterface(table: TableInfo): string {
	const fieldLines = [
		{ name: "_id", type: `Id<'${table.name}'>`, optional: false },
		{ name: "_creationTime", type: "number", optional: false },
		...table.fields.map((field) => {
			const { type, optional } = describeField(field.meta, table.name);
			return { name: field.name, type, optional };
		}),
	]
		.map(
			(field) => `\t${field.name}${field.optional ? "?" : ""}: ${field.type};`
		)
		.join("\n");
	return `export interface ${table.docInterfaceName} {\n${fieldLines}\n}`;
}

function renderHandlerSource(table: TableInfo): string {
	const handlerName = `list${table.pascalName}`;
	return `${AUTO_GENERATED_BANNER}import { query } from '../schema-types';\n\nexport const ${handlerName} = query({\n\targs: {},\n\thandler: async (ctx) => {\n\t\treturn ctx.db.query('${table.name}').collect();\n\t},\n});\n`;
}

function renderIndexesLiteral(tables: TableInfo[]): string {
	const indexMap = Object.fromEntries(
		tables.map((table) => [
			table.name,
			table.indexes.map((index) => ({
				name: index.name,
				fields: index.fields,
			})),
		])
	);
	const raw = JSON.stringify(indexMap, null, 2);
	const indented = raw
		.split("\n")
		.map((line, idx) => (idx === 0 ? line : `\t${line}`))
		.join("\n");
	return `export const tableIndexes = ${indented} as const;\n`;
}

function describeField(
	meta: ValidatorMeta,
	tableName: string
): { type: string; optional: boolean } {
	const baseType = computeBaseType(meta, tableName);
	const typeWithNull = meta.isNullable ? `${baseType} | null` : baseType;
	return {
		type: typeWithNull,
		optional: Boolean(meta.isOptional),
	};
}

function computeBaseType(meta: ValidatorMeta, tableName: string): string {
	switch (meta.kind) {
		case "string":
		case "number":
		case "boolean":
			return meta.kind;
		case "id":
			return meta.references
				? `Id<'${meta.references}'>`
				: `Id<'${tableName}'>`;
		case "literal":
			return JSON.stringify(meta.literalValue ?? null);
		case "array": {
			const inner = computeBaseType(
				meta.elementMeta ?? { kind: "unknown" },
				tableName
			);
			return `${wrapIfNeeded(inner)}[]`;
		}
		case "record": {
			const valueType = computeBaseType(
				meta.elementMeta ?? { kind: "unknown" },
				tableName
			);
			return `Record<string, ${valueType}>`;
		}
		case "object":
			return "Record<string, unknown>";
		default:
			return "unknown";
	}
}

function wrapIfNeeded(typeName: string): string {
	return typeName.includes("|") ? `(${typeName})` : typeName;
}

function pascalCase(value: string): string {
	return value
		.replace(/[^a-zA-Z0-9]+/g, " ")
		.split(" ")
		.filter(Boolean)
		.map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
		.join("");
}

async function watchForChanges(
	configPath: string,
	initialPaths: BuildPaths
): Promise<void> {
	let currentPaths = initialPaths;
	const watchers = new Map<string, FSWatcher>();
	let debounceTimer: NodeJS.Timeout | null = null;
	let building = false;
	let rerunRequested = false;

	const ensureWatchTargets = (): void => {
		const targets = new Set([currentPaths.configDir, currentPaths.projectDir]);
		targets.forEach((target) => ensureWatcher(target));
	};

	const ensureWatcher = (dir: string): void => {
		const resolvedDir = resolve(dir);
		if (watchers.has(resolvedDir)) {
			return;
		}
		try {
			const watcher = watch(
				resolvedDir,
				{ recursive: true },
				(eventType, fileName) => {
					const fullPath = fileName
						? resolve(resolvedDir, fileName.toString())
						: resolvedDir;
					if (shouldIgnore(fullPath)) {
						return;
					}
					const displayPath = relative(REPO_ROOT, fullPath) || ".";
					console.log(
						`[appflare db build] ${eventType} detected in ${displayPath}`
					);
					triggerRebuild();
				}
			);
			watcher.on("error", (error) => {
				console.error(
					`[appflare db build] Watcher error for ${
						relative(REPO_ROOT, resolvedDir) || resolvedDir
					}:`,
					error
				);
			});
			watchers.set(resolvedDir, watcher);
			console.log(
				`[appflare db build] Watching ${
					relative(REPO_ROOT, resolvedDir) || resolvedDir
				}`
			);
		} catch (error) {
			console.error(
				`[appflare db build] Failed to watch ${
					relative(REPO_ROOT, resolvedDir) || resolvedDir
				}:`,
				error
			);
		}
	};

	const shouldIgnore = (fullPath: string): boolean => {
		return (
			isSameOrSubpath(fullPath, currentPaths.generatedRoot) ||
			isSamePath(fullPath, currentPaths.tsconfigPath)
		);
	};

	const triggerRebuild = (): void => {
		if (debounceTimer) {
			clearTimeout(debounceTimer);
		}
		debounceTimer = setTimeout(async () => {
			debounceTimer = null;
			if (building) {
				rerunRequested = true;
				return;
			}
			building = true;
			try {
				currentPaths = await runDbBuild(configPath);
				ensureWatchTargets();
			} catch (error) {
				console.error("[appflare db build] Rebuild failed:", error);
			} finally {
				building = false;
				if (rerunRequested) {
					rerunRequested = false;
					triggerRebuild();
				}
			}
		}, 100);
	};

	ensureWatchTargets();
	console.log(
		"[appflare db build] Watching for changes (press Ctrl+C to exit)"
	);

	process.on("SIGINT", () => {
		console.log("\n[appflare db build] Stopping watchers...");
		for (const watcher of watchers.values()) {
			watcher.close();
		}
		process.exit(0);
	});

	await new Promise<never>(() => {
		// Keep the process alive indefinitely while watchers run.
	});
}

function isSameOrSubpath(target: string, parent: string): boolean {
	const normalizedTarget = normalizePath(target);
	const normalizedParent = normalizePath(parent);
	if (normalizedTarget === normalizedParent) {
		return true;
	}
	const parentWithSep = normalizedParent.endsWith(sep)
		? normalizedParent
		: `${normalizedParent}${sep}`;
	return normalizedTarget.startsWith(parentWithSep);
}

function isSamePath(a: string, b: string): boolean {
	return normalizePath(a) === normalizePath(b);
}

function normalizePath(value: string): string {
	return normalize(resolve(value));
}
