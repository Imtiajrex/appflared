import { mkdir, readdir, readFile, writeFile } from "node:fs/promises";
import { dirname, join, relative, resolve } from "node:path";
import { pathToFileURL } from "node:url";

import * as ts from "typescript";

import { importConfigModule, resolveConfigPathFromArgs } from "./utils.js";

const AUTO_GENERATED_BANNER = `/* eslint-disable */
/**
 * This file is auto-generated by appflare/handler-build.ts.
 * Do not edit directly.
 */
`;

const IGNORED_DIR_NAMES = new Set([
	".git",
	".turbo",
	"dist",
	"build",
	"node_modules",
	"public",
	"server",
	"_generated",
]);

type HandlerDefinition = {
	name: string;
	schemaExpression: string;
	sourcePath: string;
	kind: "query" | "mutation";
};

type HandlerBuildConfig = {
	dir: string;
	outDir: string;
};

export async function runHandlerBuild(configPath: string): Promise<void> {
	const resolvedConfigPath = resolve(configPath);
	const configDir = dirname(resolvedConfigPath);
	const config = await loadConfig(resolvedConfigPath);
	const projectDir = resolve(configDir, config.dir);
	const generatedRoot = resolve(configDir, config.outDir);
	const serverDir = join(generatedRoot, "server");
	const serverFile = join(serverDir, "server.ts");
	const apiDir = join(generatedRoot, "src");
	const apiFile = join(apiDir, "api.ts");

	const sourceFiles = await findCandidateSourceFiles(projectDir);
	const definitions: HandlerDefinition[] = [];
	for (const file of sourceFiles) {
		const contents = await readFile(file, "utf8");
		definitions.push(...extractHandlerDefinitions(file, contents));
	}

	const serverSource = renderServerSource(definitions, serverDir);
	const apiSource = renderApiSource(definitions, apiDir);
	await mkdir(serverDir, { recursive: true });
	await mkdir(apiDir, { recursive: true });
	await writeFile(serverFile, serverSource, "utf8");
	await writeFile(apiFile, apiSource, "utf8");
	console.log(
		`[appflare handler build] Generated ${definitions.length} route${
			definitions.length === 1 ? "" : "s"
		} at ${relative(process.cwd(), serverFile)} with API client at ${relative(
			process.cwd(),
			apiFile
		)}`
	);
}

async function loadConfig(configFile: string): Promise<HandlerBuildConfig> {
	const rawConfig = await importConfigModule<{ dir?: string; outDir?: string }>(
		configFile
	);
	const dir = typeof rawConfig.dir === "string" ? rawConfig.dir : ".";
	const outDir =
		typeof rawConfig.outDir === "string" ? rawConfig.outDir : "./_generated";
	return { dir, outDir };
}

async function findCandidateSourceFiles(root: string): Promise<string[]> {
	const results: string[] = [];
	await walkDirectory(root, results);
	return results.sort();
}

async function walkDirectory(dir: string, files: string[]): Promise<void> {
	const entries = await readdir(dir, { withFileTypes: true });
	for (const entry of entries) {
		if (entry.name.startsWith(".")) {
			if (IGNORED_DIR_NAMES.has(entry.name)) {
				continue;
			}
		}
		const fullPath = join(dir, entry.name);
		if (entry.isDirectory()) {
			if (IGNORED_DIR_NAMES.has(entry.name)) {
				continue;
			}
			await walkDirectory(fullPath, files);
		} else if (entry.isFile()) {
			if (entry.name.endsWith(".ts") && !entry.name.endsWith(".d.ts")) {
				files.push(fullPath);
			}
		}
	}
}

function extractHandlerDefinitions(
	filePath: string,
	sourceText: string
): HandlerDefinition[] {
	const sourceFile = ts.createSourceFile(
		filePath,
		sourceText,
		ts.ScriptTarget.Latest,
		true,
		ts.ScriptKind.TS
	);
	const definitions: HandlerDefinition[] = [];
	sourceFile.forEachChild((node) => {
		if (
			ts.isVariableStatement(node) &&
			node.modifiers?.some(
				(modifier) => modifier.kind === ts.SyntaxKind.ExportKeyword
			)
		) {
			for (const declaration of node.declarationList.declarations) {
				const definition = convertDeclarationToHandler(
					declaration,
					sourceFile,
					filePath
				);
				if (definition) {
					definitions.push(definition);
				}
			}
		}
	});
	return definitions;
}

function convertDeclarationToHandler(
	declaration: ts.VariableDeclaration,
	sourceFile: ts.SourceFile,
	filePath: string
): HandlerDefinition | null {
	if (!ts.isIdentifier(declaration.name)) {
		return null;
	}
	const initializer = declaration.initializer;
	if (!initializer || !ts.isCallExpression(initializer)) {
		return null;
	}
	const kind = getCallKind(initializer);
	if (!kind) {
		return null;
	}
	const schemaExpression = extractArgsSchema(initializer, sourceFile);
	return {
		name: declaration.name.text,
		schemaExpression,
		sourcePath: filePath,
		kind,
	};
}

function isQueryCall(expression: ts.CallExpression): boolean {
	const callee = expression.expression;
	return ts.isIdentifier(callee) && callee.text === "query";
}

function isMutationCall(expression: ts.CallExpression): boolean {
	const callee = expression.expression;
	return ts.isIdentifier(callee) && callee.text === "mutation";
}

function getCallKind(
	expression: ts.CallExpression
): HandlerDefinition["kind"] | null {
	if (isQueryCall(expression)) {
		return "query";
	}
	if (isMutationCall(expression)) {
		return "mutation";
	}
	return null;
}

function extractArgsSchema(
	callExpression: ts.CallExpression,
	sourceFile: ts.SourceFile
): string {
	if (!callExpression.arguments.length) {
		return "z.object({})";
	}
	const definitionArg = callExpression.arguments[0];
	if (!ts.isObjectLiteralExpression(definitionArg)) {
		return "z.object({})";
	}
	for (const property of definitionArg.properties) {
		if (!ts.isPropertyAssignment(property)) {
			continue;
		}
		const propertyName = getPropertyName(property.name);
		if (propertyName !== "args") {
			continue;
		}
		const initializer = property.initializer;
		const text = initializer.getText(sourceFile).trim();
		if (ts.isObjectLiteralExpression(initializer)) {
			return `z.object(${text})`;
		}
		if (ts.isCallExpression(initializer) && isZodObjectCall(initializer)) {
			return text;
		}
		return text;
	}
	return "z.object({})";
}

function getPropertyName(name: ts.PropertyName): string | undefined {
	if (
		ts.isIdentifier(name) ||
		ts.isStringLiteral(name) ||
		ts.isNumericLiteral(name)
	) {
		return name.text;
	}
	return undefined;
}

function isZodObjectCall(expression: ts.CallExpression): boolean {
	if (!ts.isPropertyAccessExpression(expression.expression)) {
		return false;
	}
	const inner = expression.expression;
	return (
		ts.isIdentifier(inner.expression) &&
		inner.expression.text === "z" &&
		inner.name.text === "object"
	);
}

function renderServerSource(
	definitions: HandlerDefinition[],
	serverDir: string
): string {
	const sorted = [...definitions].sort((a, b) => a.name.localeCompare(b.name));
	const importBlock = buildImportBlock(sorted, serverDir);
	const routes = sorted
		.map((definition) => renderRoute(definition))
		.join("\n\n")
		.trim();
	const importsSection = [
		'import { Hono } from "hono";',
		'import { sValidator } from "@hono/standard-validator";',
		'import { z } from "zod";',
		importBlock,
	]
		.filter((line) => Boolean(line))
		.join("\n");
	const contextSection = `const appflareContext = {
	db: {
		query: (tableName: string) => ({
			collect: async () => {
				return [{ id: \"1\", text: \"Hello World\" }];
			},
		}),
	}, // mock db context
} as any;`;
	const sections = [
		AUTO_GENERATED_BANNER.trimEnd(),
		importsSection,
		contextSection,
		"const app = new Hono();",
	];
	if (routes) {
		sections.push(routes);
	}
	sections.push("export default app;");
	return sections
		.filter((section) => section)
		.join("\n\n")
		.concat("\n");
}

function buildImportBlock(
	definitions: HandlerDefinition[],
	serverDir: string
): string {
	if (!definitions.length) {
		return "";
	}
	const map = new Map<string, string[]>();
	for (const definition of definitions) {
		const importPath = makeRelativeImportPath(serverDir, definition.sourcePath);
		const existing = map.get(importPath) ?? [];
		existing.push(definition.name);
		map.set(importPath, existing);
	}
	const lines = Array.from(map.entries())
		.sort((a, b) => a[0].localeCompare(b[0]))
		.map(([importPath, identifiers]) => {
			const uniqueIdentifiers = Array.from(new Set(identifiers)).sort((a, b) =>
				a.localeCompare(b)
			);
			return `import { ${uniqueIdentifiers.join(", ")} } from \"${importPath}\";`;
		});
	return lines.join("\n");
}

function makeRelativeImportPath(fromDir: string, targetFile: string): string {
	const relativePath = relative(fromDir, targetFile).replace(/\\/g, "/");
	const withoutExtension = relativePath.replace(/\.[tj]sx?$/, "");
	if (withoutExtension.startsWith(".")) {
		return withoutExtension;
	}
	return `./${withoutExtension}`;
}

function renderRoute(definition: HandlerDefinition): string {
	const schemaExpression = definition.schemaExpression.trim();
	const isQuery = definition.kind === "query";
	const method = isQuery ? "get" : "post";
	const validatorTarget = isQuery ? "query" : "json";
	const routePrefix = isQuery ? "queries" : "mutations";
	const handlerArgsVar = isQuery ? "query" : "body";
	return `app.${method}(
	"/${routePrefix}/${definition.name}",
	sValidator("${validatorTarget}", ${schemaExpression}),
	async (c) => {
		const ${handlerArgsVar} = c.req.valid("${validatorTarget}");
		const result = await ${definition.name}.handler(appflareContext, ${handlerArgsVar});
		return c.json(result, 200);
	}
);`;
}

function renderApiSource(
	definitions: HandlerDefinition[],
	apiDir: string
): string {
	const sorted = [...definitions].sort((a, b) => a.name.localeCompare(b.name));
	const hasHandlers = sorted.length > 0;
	const queries = sorted.filter((definition) => definition.kind === "query");
	const mutations = sorted.filter(
		(definition) => definition.kind === "mutation"
	);
	const typeAliasBlock = sorted
		.map((definition) => renderApiTypeAlias(definition, apiDir))
		.join("\n\n");
	const sections: string[] = [AUTO_GENERATED_BANNER.trimEnd()];
	if (hasHandlers) {
		sections.push('import fetch from "better-fetch";');
		sections.push(
			'import type { InferQueryArgs, MutationDefinition, QueryDefinition } from "./schema-types";'
		);
		sections.push(renderApiHelperTypes(true));
		if (typeAliasBlock) {
			sections.push(typeAliasBlock);
		}
	} else {
		sections.push(renderApiHelperTypes(false));
	}
	sections.push(renderApiClientType("QueriesClient", queries));
	sections.push(renderApiClientType("MutationsClient", mutations));
	sections.push(
		"export type AppflareApiClient = {\n\tqueries: QueriesClient;\n\tmutations: MutationsClient;\n};"
	);
	sections.push(
		"export type AppflareApiOptions = {\n\tbaseUrl?: string;\n\tfetcher?: RequestExecutor;\n};"
	);
	sections.push(renderCreateApiFunction(queries, mutations));
	if (hasHandlers) {
		sections.push(renderApiUtilitiesBlock());
	}
	return sections
		.filter((section) => Boolean(section))
		.join("\n\n")
		.concat("\n");
}

function renderApiHelperTypes(hasHandlers: boolean): string {
	const lines: string[] = [];
	if (hasHandlers) {
		lines.push(
			"type AnyHandlerDefinition = QueryDefinition<Record<string, unknown>, unknown> | MutationDefinition<Record<string, unknown>, unknown>;",
			"type HandlerArgs<THandler extends AnyHandlerDefinition> = THandler extends { args: infer TArgs }\n\t? InferQueryArgs<TArgs>\n\t: never;",
			"type HandlerResult<THandler extends AnyHandlerDefinition> = THandler extends {\n\thandler: (...args: any[]) => Promise<infer TResult>;\n}\n\t? TResult\n\t: never;",
			"type HandlerInvoker<TArgs, TResult> = (args: TArgs, init?: RequestInit) => Promise<TResult>;"
		);
	}
	lines.push(
		"type RequestExecutor = (\n\tinput: RequestInfo | URL,\n\tinit?: RequestInit\n) => Promise<Response>;"
	);
	if (hasHandlers) {
		lines.push(
			"const defaultFetcher: RequestExecutor = (input, init) => fetch(input, init);"
		);
	}
	return lines.join("\n\n");
}

function renderApiTypeAlias(
	definition: HandlerDefinition,
	apiDir: string
): string {
	const baseName = pascalCase(definition.name);
	const defType = `${baseName}Definition`;
	const argsType = `${baseName}Args`;
	const resultType = `${baseName}Result`;
	const importPath = makeRelativeImportPath(apiDir, definition.sourcePath);
	return [
		`type ${defType} = typeof import("${importPath}")["${definition.name}"];`,
		`type ${argsType} = HandlerArgs<${defType}>;`,
		`type ${resultType} = HandlerResult<${defType}>;`,
	].join("\n");
}

function renderApiClientType(
	interfaceName: string,
	definitions: HandlerDefinition[]
): string {
	if (!definitions.length) {
		return `export type ${interfaceName} = Record<string, never>;`;
	}
	const lines = definitions
		.map((definition) => {
			const baseName = pascalCase(definition.name);
			return `\t${definition.name}: HandlerInvoker<${baseName}Args, ${baseName}Result>;`;
		})
		.join("\n");
	return `export type ${interfaceName} = {\n${lines}\n};`;
}

function renderCreateApiFunction(
	queries: HandlerDefinition[],
	mutations: HandlerDefinition[]
): string {
	const hasHandlers = queries.length > 0 || mutations.length > 0;
	if (!hasHandlers) {
		return [
			"export function createAppflareApi(options: AppflareApiOptions = {}): AppflareApiClient {",
			"\treturn {",
			"\t\tqueries: {},",
			"\t\tmutations: {},",
			"\t};",
			"}",
		].join("\n");
	}
	const queryBlock = renderApiClientBlock(
		"queries",
		"QueriesClient",
		queries,
		renderQueryMethod
	);
	const mutationBlock = renderApiClientBlock(
		"mutations",
		"MutationsClient",
		mutations,
		renderMutationMethod
	);
	return [
		"export function createAppflareApi(options: AppflareApiOptions = {}): AppflareApiClient {",
		"\tconst baseUrl = normalizeBaseUrl(options.baseUrl);",
		"\tconst request = options.fetcher ?? defaultFetcher;",
		"",
		queryBlock,
		"",
		mutationBlock,
		"",
		"\treturn { queries, mutations };",
		"}",
	]
		.filter((line) => Boolean(line))
		.join("\n");
}

function renderApiClientBlock(
	propertyName: string,
	interfaceName: string,
	definitions: HandlerDefinition[],
	renderMethod: (definition: HandlerDefinition) => string
): string {
	if (!definitions.length) {
		return `\tconst ${propertyName}: ${interfaceName} = {};`;
	}
	const methods = definitions.map(renderMethod).join("\n\n");
	return `\tconst ${propertyName}: ${interfaceName} = {\n${methods}\n\t};`;
}

function renderQueryMethod(definition: HandlerDefinition): string {
	const baseName = pascalCase(definition.name);
	const argsType = `${baseName}Args`;
	const resultType = `${baseName}Result`;
	return [
		`\t\t${definition.name}: async (args: ${argsType}, init) => {`,
		`\t\t\tconst url = buildQueryUrl(baseUrl, "/queries/${definition.name}", args);`,
		"\t\t\tconst response = await request(url, {",
		"\t\t\t\t...(init ?? {}),",
		'\t\t\t\tmethod: "GET",',
		"\t\t\t});",
		`\t\t\treturn parseJson<${resultType}>(response);`,
		"\t\t},",
	].join("\n");
}

function renderMutationMethod(definition: HandlerDefinition): string {
	const baseName = pascalCase(definition.name);
	const argsType = `${baseName}Args`;
	const resultType = `${baseName}Result`;
	return [
		`\t\t${definition.name}: async (args: ${argsType}, init) => {`,
		`\t\t\tconst url = buildUrl(baseUrl, "/mutations/${definition.name}");`,
		"\t\t\tconst response = await request(url, {",
		"\t\t\t\t...(init ?? {}),",
		'\t\t\t\tmethod: "POST",',
		"\t\t\t\theaders: ensureJsonHeaders(init?.headers),",
		"\t\t\t\tbody: JSON.stringify(args),",
		"\t\t\t});",
		`\t\t\treturn parseJson<${resultType}>(response);`,
		"\t\t},",
	].join("\n");
}

function renderApiUtilitiesBlock(): string {
	const lines = [
		"function normalizeBaseUrl(baseUrl?: string): string {",
		"\tif (!baseUrl) {",
		'\t\treturn "";',
		"\t}",
		'\treturn baseUrl.endsWith("/") ? baseUrl.slice(0, -1) : baseUrl;',
		"}",
		"",
		"function buildUrl(baseUrl: string, path: string): string {",
		"\tif (!baseUrl) {",
		"\t\treturn path;",
		"\t}",
		'\tconst normalizedPath = path.startsWith("/") ? path : `/${path}`;',
		"\treturn `${baseUrl}${normalizedPath}`;",
		"}",
		"",
		"function buildQueryUrl(\n\tbaseUrl: string,\n\tpath: string,\n\tparams: Record<string, unknown> | undefined\n): string {",
		"\tconst url = buildUrl(baseUrl, path);",
		"\tconst query = serializeQueryParams(params);",
		"\treturn query ? `${url}?${query}` : url;",
		"}",
		"",
		"function serializeQueryParams(\n\tparams: Record<string, unknown> | undefined\n): string {",
		"\tif (!params) {",
		'\t\treturn "";',
		"\t}",
		"\tconst searchParams = new URLSearchParams();",
		"\tfor (const [key, value] of Object.entries(params)) {",
		"\t\tif (value === undefined || value === null) {",
		"\t\t\tcontinue;",
		"\t\t}",
		"\t\tif (Array.isArray(value)) {",
		"\t\t\tfor (const entry of value) {",
		"\t\t\t\tsearchParams.append(key, serializeQueryValue(entry));",
		"\t\t\t}",
		"\t\t\tcontinue;",
		"\t\t}",
		"\t\tsearchParams.append(key, serializeQueryValue(value));",
		"\t}",
		"\treturn searchParams.toString();",
		"}",
		"",
		"function serializeQueryValue(value: unknown): string {",
		"\tif (value instanceof Date) {",
		"\t\treturn value.toISOString();",
		"\t}",
		'\tif (typeof value === "object") {',
		"\t\treturn JSON.stringify(value);",
		"\t}",
		"\treturn String(value);",
		"}",
		"",
		"function ensureJsonHeaders(headers?: HeadersInit): HeadersInit {",
		"\tif (!headers) {",
		'\t\treturn { "content-type": "application/json" };',
		"\t}",
		'\tif (typeof Headers !== "undefined" && headers instanceof Headers) {',
		"\t\tconst next = new Headers(headers);",
		'\t\tif (!next.has("content-type")) {',
		'\t\t\tnext.set("content-type", "application/json");',
		"\t\t}",
		"\t\treturn next;",
		"\t}",
		"\tif (Array.isArray(headers)) {",
		"\t\tconst entries = headers.slice();",
		'\t\tconst hasContentType = entries.some(\n\t\t\t([key]) => key.toLowerCase() === "content-type"\n\t\t);',
		"\t\tif (!hasContentType) {",
		'\t\t\tentries.push(["content-type", "application/json"]);',
		"\t\t}",
		"\t\treturn entries;",
		"\t}",
		'\tif (typeof headers === "object") {',
		"\t\tconst record = { ...(headers as Record<string, string>) };",
		'\t\tif (!hasHeader(record, "content-type")) {',
		'\t\t\trecord["content-type"] = "application/json";',
		"\t\t}",
		"\t\treturn record;",
		"\t}",
		'\treturn { "content-type": "application/json" };',
		"}",
		"",
		"function hasHeader(record: Record<string, string>, name: string): boolean {",
		"\tconst needle = name.toLowerCase();",
		"\treturn Object.keys(record).some((key) => key.toLowerCase() === needle);",
		"}",
		"",
		"async function parseJson<TResult>(response: Response): Promise<TResult> {",
		"\tif (!response.ok) {",
		"\t\tthrow new Error(`Request failed with status ${response.status}`);",
		"\t}",
		"\treturn (await response.json()) as TResult;",
		"}",
	];
	return lines.join("\n");
}

function pascalCase(value: string): string {
	return value
		.replace(/[^a-zA-Z0-9]+/g, " ")
		.split(" ")
		.filter(Boolean)
		.map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
		.join("");
}

const ENTRY_URL = process.argv[1]
	? pathToFileURL(process.argv[1]).href
	: undefined;

if (ENTRY_URL && import.meta.url === ENTRY_URL) {
	void (async () => {
		try {
			const configPath = resolveConfigPathFromArgs();
			await runHandlerBuild(configPath);
		} catch (error) {
			console.error("[appflare handler build] failed:", error);
			process.exitCode = 1;
		}
	})();
}
