import { spawn } from 'node:child_process';
import { mkdir, rm, writeFile } from 'node:fs/promises';
import { join, relative, resolve } from 'node:path';
import { fileURLToPath, pathToFileURL } from 'node:url';

import type { AnyValidator, SchemaDefinition, ValidatorMeta } from './db';

type TableFieldInfo = {
	name: string;
	meta: ValidatorMeta;
};

type TableInfo = {
	name: string;
	pascalName: string;
	docInterfaceName: string;
	fields: TableFieldInfo[];
	indexes: Array<{ name: string; fields: string[] }>;
};

const AUTO_GENERATED_BANNER = `/* eslint-disable */
/**
 * This file is auto-generated by appflare/build.ts.
 * Do not edit directly.
 */
`;

const THIS_FILE = fileURLToPath(import.meta.url);
const THIS_DIR = resolve(THIS_FILE, '..');
const REPO_ROOT = resolve(THIS_DIR, '..');
const EXAMPLE_DIR = join(REPO_ROOT, 'appflare-example');
const SCHEMA_PATH = join(EXAMPLE_DIR, 'schema.ts');
const GENERATED_ROOT = join(EXAMPLE_DIR, '_generated');
const SRC_DIR = join(GENERATED_ROOT, 'src');
const HANDLERS_DIR = join(SRC_DIR, 'handlers');
const DIST_DIR = join(GENERATED_ROOT, 'dist');
const TSCONFIG_PATH = join(EXAMPLE_DIR, 'tsconfig.generated.json');

void (async () => {
	try {
		await main();
	} catch (error) {
		console.error('[appflare build] failed:', error);
		process.exitCode = 1;
	}
})();

async function main(): Promise<void> {
	const schema = await loadSchema(SCHEMA_PATH);
	const tables = extractTables(schema);
	if (tables.length === 0) {
		throw new Error('No tables were found in appflare-example/schema.ts');
	}
	await prepareOutputDirs();
	await writeSchemaTypesFile(tables);
	await Promise.all(tables.map((table) => writeHandlerFile(table)));
	await writeHandlerIndex(tables);
	await ensureGeneratedTsconfig();
	await runTsc(TSCONFIG_PATH);
	console.log(
		`[appflare build] Generated ${tables.length} table handler${tables.length === 1 ? '' : 's'} under ${relative(
			REPO_ROOT,
			GENERATED_ROOT,
		)}`,
	);
}

async function loadSchema(schemaFile: string): Promise<SchemaDefinition<Record<string, unknown>>> {
	const moduleUrl = pathToFileURL(schemaFile).href;
	const imported = await import(moduleUrl);
	const schema = imported.default;
	if (!schema || typeof schema !== 'object' || !('tableNames' in schema)) {
		throw new Error(`Schema at ${relative(REPO_ROOT, schemaFile)} does not export a default schema definition.`);
	}
	return schema as SchemaDefinition<Record<string, unknown>>;
}

function extractTables(schema: SchemaDefinition<Record<string, unknown>>): TableInfo[] {
	return schema.tableNames.map((tableName) => {
		const tableDef = schema.getTable(tableName);
		const fields = Object.entries(tableDef.fields ?? {}) as Array<[string, AnyValidator]>;
		return {
			name: tableName,
			pascalName: pascalCase(tableName),
			docInterfaceName: `${pascalCase(tableName)}Doc`,
			fields: fields.map(([fieldName, validator]) => ({
				name: fieldName,
				meta: validator.meta,
			})),
			indexes: tableDef.indexes ?? [],
		};
	});
}

async function prepareOutputDirs(): Promise<void> {
	await rm(SRC_DIR, { recursive: true, force: true });
	await rm(DIST_DIR, { recursive: true, force: true });
	await mkdir(HANDLERS_DIR, { recursive: true });
}

async function writeSchemaTypesFile(tables: TableInfo[]): Promise<void> {
	const target = join(SRC_DIR, 'schema-types.ts');
	await mkdir(SRC_DIR, { recursive: true });
	await writeFile(target, renderSchemaTypes(tables), 'utf8');
}

async function writeHandlerFile(table: TableInfo): Promise<void> {
	const target = join(HANDLERS_DIR, `${table.name}.ts`);
	await writeFile(target, renderHandlerSource(table), 'utf8');
}

async function writeHandlerIndex(tables: TableInfo[]): Promise<void> {
	const target = join(HANDLERS_DIR, 'index.ts');
	const exports = tables.map((table) => `export * from './${table.name}';`).join('\n');
	await writeFile(target, `${AUTO_GENERATED_BANNER}${exports}\n`, 'utf8');
}

async function ensureGeneratedTsconfig(): Promise<void> {
	const config = {
		extends: '../tsconfig.json',
		compilerOptions: {
			noEmit: false,
			declaration: true,
			emitDeclarationOnly: false,
			outDir: './_generated/dist',
			rootDir: './_generated/src',
			sourceMap: false,
			declarationMap: false,
			skipLibCheck: true,
			types: [],
		},
		include: ['./_generated/src/**/*'],
	};
	const json = `${JSON.stringify(config, null, 2)}\n`;
	await writeFile(TSCONFIG_PATH, json, 'utf8');
}

async function runTsc(tsconfig: string): Promise<void> {
	await runCommand('npx', ['tsc', '-p', tsconfig], REPO_ROOT);
}

function runCommand(command: string, args: string[], cwd: string): Promise<void> {
	return new Promise((resolvePromise, rejectPromise) => {
		const child = spawn(command, args, {
			cwd,
			stdio: 'inherit',
			shell: false,
		});
		child.on('exit', (code) => {
			if (code === 0) {
				resolvePromise();
			} else {
				rejectPromise(new Error(`${command} ${args.join(' ')} exited with code ${code}`));
			}
		});
		child.on('error', (error) => rejectPromise(error));
	});
}

function renderSchemaTypes(tables: TableInfo[]): string {
	const tableNamesUnion = tables.map((table) => `'${table.name}'`).join(' | ');
	const docInterfaces = tables.map((table) => renderDocInterface(table)).join('\n\n');
	const tableMapLines = tables.map((table) => `\t'${table.name}': ${table.docInterfaceName};`).join('\n');
	const indexesLiteral = renderIndexesLiteral(tables);
	return `${AUTO_GENERATED_BANNER}type SchemaValidator<TValue> = {\n\tparse: (value: unknown) => TValue;\n};\n\nexport type AnyValidator = SchemaValidator<unknown>;\n\nexport type TableNames = ${tableNamesUnion};\n\nexport type Id<TableName extends string> = string & { __table?: TableName };\n\n${docInterfaces}\n\nexport interface TableDocMap {\n${tableMapLines}\n}\n\nexport type Doc<TableName extends TableNames> = TableDocMap[TableName];\n\nexport interface DatabaseQuery<TableName extends TableNames> {\n\tcollect(): Promise<Array<TableDocMap[TableName]>>;\n}\n\nexport interface DatabaseReader {\n\tquery<TableName extends TableNames>(table: TableName): DatabaseQuery<TableName>;\n}\n\nexport interface QueryContext {\n\tdb: DatabaseReader;\n}\n\nexport type QueryArgsShape = Record<string, AnyValidator>;\n\ntype InferValidator<TValidator> = TValidator extends SchemaValidator<infer TValue> ? TValue : never;\n\nexport type InferQueryArgs<TArgs extends QueryArgsShape> = {\n\t[Key in keyof TArgs]: InferValidator<TArgs[Key]>;\n};\n\nexport interface QueryDefinition<TArgs extends QueryArgsShape, TResult> {\n\targs: TArgs;\n\thandler: (ctx: QueryContext, args: InferQueryArgs<TArgs>) => Promise<TResult>;\n}\n\nexport const query = <TArgs extends QueryArgsShape, TResult>(definition: QueryDefinition<TArgs, TResult>): QueryDefinition<TArgs, TResult> => definition;\n\n${indexesLiteral}`;
}

function renderDocInterface(table: TableInfo): string {
	const fieldLines = [
		{ name: '_id', type: `Id<'${table.name}'>`, optional: false },
		{ name: '_creationTime', type: 'number', optional: false },
		...table.fields.map((field) => {
			const { type, optional } = describeField(field.meta, table.name);
			return { name: field.name, type, optional };
		}),
	]
		.map((field) => `\t${field.name}${field.optional ? '?' : ''}: ${field.type};`)
		.join('\n');
	return `export interface ${table.docInterfaceName} {\n${fieldLines}\n}`;
}

function renderHandlerSource(table: TableInfo): string {
	const handlerName = `list${table.pascalName}`;
	return `${AUTO_GENERATED_BANNER}import { query } from '../schema-types';\n\nexport const ${handlerName} = query({\n\targs: {},\n\thandler: async (ctx) => {\n\t\treturn ctx.db.query('${table.name}').collect();\n\t},\n});\n`;
}

function renderIndexesLiteral(tables: TableInfo[]): string {
	const indexMap = Object.fromEntries(
		tables.map((table) => [table.name, table.indexes.map((index) => ({ name: index.name, fields: index.fields }))]),
	);
	const raw = JSON.stringify(indexMap, null, 2);
	const indented = raw
		.split('\n')
		.map((line, idx) => (idx === 0 ? line : `\t${line}`))
		.join('\n');
	return `export const tableIndexes = ${indented} as const;\n`;
}

function describeField(meta: ValidatorMeta, tableName: string): { type: string; optional: boolean } {
	const baseType = computeBaseType(meta, tableName);
	const typeWithNull = meta.isNullable ? `${baseType} | null` : baseType;
	return {
		type: typeWithNull,
		optional: Boolean(meta.isOptional),
	};
}

function computeBaseType(meta: ValidatorMeta, tableName: string): string {
	switch (meta.kind) {
		case 'string':
		case 'number':
		case 'boolean':
			return meta.kind;
		case 'id':
			return meta.references ? `Id<'${meta.references}'>` : `Id<'${tableName}'>`;
		case 'literal':
			return JSON.stringify(meta.literalValue ?? null);
		case 'array': {
			const inner = computeBaseType(meta.elementMeta ?? { kind: 'unknown' }, tableName);
			return `${wrapIfNeeded(inner)}[]`;
		}
		case 'record': {
			const valueType = computeBaseType(meta.elementMeta ?? { kind: 'unknown' }, tableName);
			return `Record<string, ${valueType}>`;
		}
		case 'object':
			return 'Record<string, unknown>';
		default:
			return 'unknown';
	}
}

function wrapIfNeeded(typeName: string): string {
	return typeName.includes('|') ? `(${typeName})` : typeName;
}

function pascalCase(value: string): string {
	return value
		.replace(/[^a-zA-Z0-9]+/g, ' ')
		.split(' ')
		.filter(Boolean)
		.map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
		.join('');
}
