/* eslint-disable */
/**
 * This file is auto-generated by appflare/db-build.ts.
 * Do not edit directly.
 */
import { z } from "zod";
import {
	mutation,
	query,
	type EditableDoc,
	type Id,
	type QuerySort,
	type QueryWhere,
} from "../schema-types";

export const findUsers = query({
	args: {
		where: z.custom<QueryWhere<"users">>().optional(),
		sort: z.custom<QuerySort<"users">>().optional(),
		limit: z.number().int().nonnegative().optional(),
		offset: z.number().int().nonnegative().optional(),
	},
	handler: async (ctx, args) => {
		return ctx.db["users" as any].findMany({
			where: args.where as any,
			orderBy: args.sort as any,
			skip: args.offset,
			take: args.limit,
		});
	},
});

export const findOneUsers = query({
	args: {
		where: z.custom<QueryWhere<"users">>().optional(),
		sort: z.custom<QuerySort<"users">>().optional(),
		offset: z.number().int().nonnegative().optional(),
	},
	handler: async (ctx, args) => {
		return ctx.db["users" as any].findFirst({
			where: args.where as any,
			orderBy: args.sort as any,
			skip: args.offset,
			take: 1,
		});
	},
});

export const insertUsers = mutation({
	args: {
		value: z.custom<EditableDoc<"users">>(),
	},
	handler: async (ctx, args) => {
		return ctx.db["users" as any].create({
			data: args.value as any,
		});
	},
});

export const updateUsers = mutation({
	args: {
		id: z.custom<Id<"users">>().optional(),
		where: z.custom<QueryWhere<"users">>().optional(),
		partial: z.custom<Partial<EditableDoc<"users">>>(),
	},
	handler: async (ctx, args) => {
		const filter = (args.where ?? args.id) as any;
		if (!filter) {
			throw new Error("update requires either args.where or args.id");
		}
		await ctx.db["users" as any].update({
			where: filter,
			data: args.partial as any,
		});
	},
});

export const deleteUsers = mutation({
	args: {
		id: z.custom<Id<"users">>().optional(),
		where: z.custom<QueryWhere<"users">>().optional(),
	},
	handler: async (ctx, args) => {
		const filter = (args.where ?? args.id) as any;
		if (!filter) {
			throw new Error("delete requires either args.where or args.id");
		}
		await ctx.db["users" as any].delete({
			where: filter,
		});
	},
});
